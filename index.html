<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Video → GIF Converter</title>
  <style>
    :root {
      --bg: #0f1115;
      --panel: #161a22;
      --text: #e8eef3;
      --muted: #9aa5b1;
      --accent: #4ea1ff;
      --border: #232a36;
      --warn: #ffb454;
      --danger: #ff6b6b;
      --ok: #4ade80;
    }
    :root[data-theme="light"] {
      --bg: #f7f9fc;
      --panel: #ffffff;
      --text: #0b1220;
      --muted: #5b6b7c;
      --accent: #2a72ff;
      --border: #d8e0ea;
      --warn: #b36200;
      --danger: #b42318;
      --ok: #137a29;
    }
    * { box-sizing: border-box; }
    body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Noto Sans, Arial, "Apple Color Emoji", "Segoe UI Emoji"; background: var(--bg); color: var(--text); }
    header {
      padding: 14px 18px; background: linear-gradient(180deg, #111521, #0d1017);
      border-bottom: 1px solid var(--border);
      position: sticky; top: 0; z-index: 5;
      display: flex; align-items: center; gap: 12px; justify-content: space-between;
    }
    :root[data-theme="light"] header { background: linear-gradient(180deg, #ffffff, #f1f5fb); }
    header h1 { font-size: 18px; margin: 0; font-weight: 600; letter-spacing: .2px; }
    .head-right { display: flex; align-items: center; gap: 8px; }
    main { display: grid; grid-template-columns: 360px 1fr; gap: 16px; padding: 16px; }
    @media (max-width: 980px) { main { grid-template-columns: 1fr; } }

    .panel { background: var(--panel); border: 1px solid var(--border); border-radius: 16px; overflow: clip; }
    .panel h2 { font-size: 14px; margin: 0; padding: 14px 16px; border-bottom: 1px solid var(--border); color: var(--muted); font-weight: 600; text-transform: uppercase; letter-spacing: .08em; }

    .controls { padding: 12px 14px; display: grid; gap: 12px; }
    .row { display: grid; grid-template-columns: 1fr auto; align-items: center; gap: 10px; }
    .muted { color: var(--muted); font-size: 12px; }
    .drop { display: grid; place-items: center; padding: 18px; text-align: center; gap: 10px; border: 2px dashed #2a3547; border-radius: 14px; color: var(--muted); background: #0c1017; cursor: pointer; min-height: 120px; }
    .drop.drag { border-color: var(--accent); color: var(--text); background: #0d1320; }
    :root[data-theme="light"] .drop { background: #f2f6fb; border-color: #c9d5e3; }
    :root[data-theme="light"] .drop.drag { background: #e9f1ff; }
    .btn-primary { background: linear-gradient(180deg, var(--accent), #255ee9); border: none; color: #fff; border-radius: 10px; padding: 8px 10px; }
    .btn-ghost { background: transparent; border: 1px dashed var(--border); color: var(--muted); border-radius: 10px; padding: 8px 10px; }
    .btn-ghost.active { background: transparent; border: 1px dashed var(--accent); color: var(--text); border-radius: 10px; padding: 8px 10px; background: rgba(78,161,255,.08);}
    button { cursor: pointer; transition: transform .02s ease; }
    button:active { transform: translateY(1px); }
    input[type=file]{ display: none; }

    /* Option segments */
    .seg { display: flex; gap: 10px; }
    .seg button { flex: 1 1 0; min-width: 0; text-align: center; background: transparent; border: 1px dashed var(--border); color: var(--muted); border-radius: 10px; padding: 8px 10px; cursor: pointer; }
    .seg button.active { border-color: var(--accent); color: var(--text); background: rgba(78,161,255,.08); }

    /* Divider between labels and the controls beneath */
    .panel[aria-label="Controls"] .controls .control > label { display: block; padding-bottom: 6px; margin-bottom: 8px; border-bottom: 1px solid var(--border); }
    /* Divider above Trim sliders following its heading */
    .panel[aria-label="Controls"] .controls .muted + .trim { border-top: 1px solid var(--border); padding-top: 8px; margin-top: 6px; }

    /* Trim range UI */
    .trim{ position:relative; height:28px; display:grid; align-items:center; --start:0%; --end:100%; }
    .trim input[type=range]{ -webkit-appearance:none; appearance:none; width:100%; background:transparent; position:absolute; left:0; right:0; pointer-events:none; z-index:2; }
    .trim input[type=range]::-webkit-slider-runnable-track{ height:6px; background:transparent; border-radius:999px; }
    .trim input[type=range]::-moz-range-track{ height:6px; background:transparent; border-radius:999px; }
    .trim input[type=range]::-webkit-slider-thumb{ -webkit-appearance:none; appearance:none; width:14px; height:14px; border-radius:50%; background: var(--accent); margin-top:-4px; border:0; pointer-events:auto; cursor:grab; }
    .trim input[type=range]::-moz-range-thumb{ width:14px; height:14px; border-radius:50%; background: var(--accent); border:0; pointer-events:auto; cursor:grab; }
    .trim .rail{ position:absolute; left:0; right:0; top:50%; transform:translateY(-50%); height:6px; background: var(--border); border-radius:999px; pointer-events:none; z-index:0; }
    .trim .highlight{ position:absolute; top:50%; transform:translateY(-50%); height:6px; left:var(--start); right:calc(100% - var(--end)); background: linear-gradient(90deg, var(--accent), #2a72ff); border-radius:999px; pointer-events:none; z-index:1; }

    /* Progress + status */
    .progress{ position:relative; height:10px; background: transparent; border:1px solid var(--border); border-radius:999px; overflow:hidden }
    .bar{ position:absolute; inset:0 100% 0 0; background: linear-gradient(90deg, var(--accent), #2a72ff 50%, var(--accent)); transition: inset .2s ease }
    .status { display:flex; align-items:center; gap:8px; font-size:12px; }
    .badge { border-radius: 999px; padding:2px 8px; border:1px solid var(--border); }
    .badge.ok { color: var(--ok); border-color: rgba(74,222,128,.35); }
    .badge.warn { color: var(--warn); border-color: rgba(255,180,84,.35); }
    .badge.err { color: var(--danger); border-color: rgba(255,107,107,.35); }

    .panel[aria-label="Preview"] { display: flex; flex-direction: column; height: 100%; }
    .panel[aria-label="Preview"] .canvas-wrap { flex: 1 1 auto; overflow: hidden; display: flex; align-items: stretch; justify-content: center; padding: 12px; min-height: 400px; }
    .preview { display: flex; gap: 12px; align-items: center; justify-content: center; }
    .preview .hint { color: var(--muted); opacity: .85; }
    .preview img, .preview video { max-width: 100%; max-height: 460px; display: block; border-radius: 12px; background: #0b1022; border: 1px dashed var(--border); }

    /* Dev panel */
    #devPanel{ display:none; margin-top:10px; padding:10px; border-radius:12px; background: transparent; border:1px dashed var(--border); }
    #devPanel label{ font-size:12px; color:var(--muted); display:flex; align-items:center; gap:8px; margin:6px 0; }
    #devPanel input[type=number]{ width:100px; background:transparent; color:var(--text); border:1px solid var(--border); border-radius:8px; padding:6px 8px; }
    #devPanel input[type=range]{ width:160px; }
    #devLog{ font-size:12px; color:var(--muted); white-space:pre-wrap; margin-top:6px; }
    
    /* Select dropdown styling */
    select { background: var(--panel); color: var(--text); border: 1px solid var(--border); border-radius: 8px; padding: 6px 8px; font-size: 13px; min-width: 120px; cursor: pointer; }
    select:focus { outline: none; border-color: var(--accent); }
    select option { background: var(--panel); color: var(--text); }

    /* Timeline and Video Controls */
    .timeline-container {
      position: relative;
      height: 20px;
      padding: 4px 0;
      cursor: pointer;
      overflow: visible;
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
    }

    .timeline {
      position: relative;
      height: 10px;
      background: var(--border);
      border-radius: 2px;
      cursor: pointer;
      transition: height 0.4s;
    }

    .timeline:hover {
      height: 12px;
    }

    .timeline-marker {
      position: absolute;
      width: 8px;
      height: 16px;
      top: 50%;
      transform: translate(-50%, -50%);
      cursor: grab;
      z-index: 2;
      font-family: monospace;
      display: flex;
      align-items: center;
      justify-content: center;
      background: none;
      border: none;
      border-radius: 0;
      transition: transform 0.2s;
    }

    .timeline-marker:active {
      cursor: grabbing;
    }

    .timeline-marker:hover {
      transform: translate(-50%, -50%) scale(1.2);
    }

    .start-marker::before {
      content: '[';
      position: absolute;
      left: -2px;
      color: var(--ok);
      font-size: 20px;
    }

    .end-marker::before {
      content: ']';
      position: absolute;
      right: -2px;
      color: var(--danger);
      font-size: 20px;
    }

    .playhead {
      position: absolute;
      width: 2px;
      height: 16px;
      background: #e2e8f0;
      top: 50%;
      transform: translateY(-50%);
      pointer-events: auto;
      display: none;
      z-index: 1;
      cursor: grab;
    }

    .playhead:active {
      cursor: grabbing;
    }

    .playhead::after {
      content: '';
      position: absolute;
      top: -4px;
      left: -4px;
      width: 10px;
      height: 10px;
      background: #e2e8f0;
      border-radius: 50%;
      transform: translateY(-50%);
    }

    .marker-times {
      display: flex;
      justify-content: space-between;
      margin-top: 4px;
      font-size: 0.8em;
      color: var(--text);
    }

    .duration-time {
      color: var(--accent);
      font-weight: 500;
    }

    .time-control {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }

    .time-input-group {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .time-input {
      width: 80px;
      background: var(--panel);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 6px 8px;
      font-size: 13px;
    }

    .time-input:focus {
      outline: none;
      border-color: var(--accent);
    }

    .setting-group {
      margin-bottom: 12px;
    }

    .setting-group label {
      display: block;
      margin-bottom: 6px;
      font-size: 13px;
      color: var(--muted);
      font-weight: 600;
    }

    /* Play button active state for loop mode */
    .play-pause-btn {
      transition: all 0.2s ease;
      position: relative;
    }

    .play-pause-btn:not(:disabled):hover {
      transform: translateY(-1px);
    }
    /* Crop functionality styles */
    .crop-overlay {
      position: absolute;
      top: 0;
      left: 0;
      background: rgba(0, 0, 0, 0.5);
      pointer-events: none;
      z-index: 1;
    }

    .crop-region {
      position: absolute;
      border: 2px solid var(--accent);
      background: rgba(74, 161, 255, 0.1);
      cursor: move;
      touch-action: none;
      pointer-events: auto;
      z-index: 2;
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
    }

    .crop-handle {
      position: absolute;
      width: 12px;
      height: 12px;
      background: var(--accent);
      border: 2px solid white;
      border-radius: 50%;
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
    }

    .crop-handle.nw { top: -6px; left: -6px; cursor: nw-resize; }
    .crop-handle.ne { top: -6px; right: -6px; cursor: ne-resize; }
    .crop-handle.sw { bottom: -6px; left: -6px; cursor: sw-resize; }
    .crop-handle.se { bottom: -6px; right: -6px; cursor: se-resize; }

    #cropDimensions {
      margin-top: 8px;
      font-size: 0.9em;
      color: var(--text);
    }

    /* Dragging active styles */
    .dragging-active {
      user-select: none !important;
      -webkit-user-select: none !important;
      -moz-user-select: none !important;
      -ms-user-select: none !important;
      cursor: grabbing !important;
    }

  </style>
</head>
<body>
  <header>
    <h1>Video → GIF Converter</h1>
    <div class="head-right">
      <div class="muted">Processed entirely on-device.</div>
      <button id="themeToggle" class="btn-ghost" title="Toggle light/dark mode" aria-pressed="false">Light mode</button>
    </div>
  </header>

  <main>
    <section class="panel" aria-label="Controls">
      <h2>Controls</h2>
      <div class="controls">
        <div class="drop" id="drop">
          <div>
            <div style="font-weight:600;color:#cfe3ff">Drop video here</div>
            <small class="muted">…or click to select a file</small>
          </div>
          <input id="fileInput" type="file" accept="video/*" hidden />
        </div>

        <div class="row">
          <div class="control">
            <label class="muted" style="font-size:13px">Output FPS</label>
            <div class="seg" id="fpsSeg"></div>
          </div>
        </div>
        <div class="row">
          <div class="control">
            <label class="muted" style="font-size:13px">Scale</label>
            <div class="seg" id="scaleSeg"></div>
          </div>
        </div>
        <div class="row">
          <div class="control">
            <label class="muted" style="font-size:13px">Palette quality</label>
            <div class="seg" id="palPresetSeg"></div>
          </div>
        </div>
        <div class="row">
          <div class="control">
            <label class="muted" style="font-size:13px">Encoder</label>
            <div class="seg" id="encoderSeg"></div>
          </div>
        </div>
        <div class="row">
          <div class="control" style="display: grid;">
            <label class="muted" style="font-size:13px">Dithering</label>
            <select id="ditherSelect">
              <option value="none" selected>None</option>
              <option value="FloydSteinberg">Floyd-Steinberg</option>
              <option value="FalseFloydSteinberg">False Floyd-Steinberg</option>
              <option value="Stucki">Stucki</option>
              <option value="Atkinson">Atkinson</option>
            </select>
          </div>
        </div>

        <div class="row">
          <div class="control">
            <label class="muted" style="font-size:13px">Start and Stop Times</label>
            <div class="row" style="display: flex; justify-content: space-between;">
              <small><label style="color: var(--ok)">Start:</label></small>
              <div class="time-input-group">
                <input type="number" id="startTime" class="time-input" value="0.00" min="0" step="0.01" pattern="\d*\.?\d{0,2}" style="-webkit-appearance: none; -moz-appearance: textfield;">
              </div>
              <small><label style="color: var(--danger)">End:</label></small>
              <div class="time-input-group">
                <input type="number" id="endTime" class="time-input" value="0.00" min="0" step="0.01" pattern="\d*\.?\d{0,2}" style="-webkit-appearance: none; -moz-appearance: textfield;">
              </div>
            </div>
          </div>
        </div>

        <button id="toggleCrop" class="btn-ghost">
          <span>Enable Crop</span>
          <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M6.13 1L6 16a2 2 0 0 0 2 2h15"></path>
            <path d="M1 6.13L16 6a2 2 0 0 1 2 2v15"></path>
          </svg>
        </button>

        <div class="row" style="grid-template-columns: 1fr 1fr 1fr;">
          <button id="webpBtn" class="btn-primary" disabled>Export WebP</button>
          <button id="webmBtn" class="btn-primary" disabled>Export WebM</button>
          <button id="goBtn" class="btn-primary" disabled>Export GIF</button>
        </div>
        <div class="row" style="grid-template-columns: 1fr 1fr;">
          <button id="resetBtn" class="btn-ghost" disabled>Reset</button>
          <button id="devToggleBtn" class="btn-ghost" aria-controls="devPanel" aria-expanded="false" title="Toggle dev panel">Dev</button>
        </div>
        </div>

        

        <div id="devPanel">
          <div class="muted" style="margin-bottom:6px">Dev (toggle with <strong>Ctrl/⌘ + D</strong> or the <strong>Dev</strong> button)</div>
          <label><input type="checkbox" id="devGlobal" checked> Use single global palette (less flicker)</label>
          <label>Dither strength <input type="range" id="devDitherS" min="0" max="48" value="18"> <span id="devDitherSV" class="muted">18</span></label>
          <label>Palette sample cap <input type="number" id="devSampleCap" value="20000000" step="1000"></label>
          <label>Pixel step <input type="number" id="devPixStep" value="4" min="1" max="16"></label>
          <div id="devLog"></div>
        </div>
      </div>
    </section>

    <section class="panel" aria-label="Preview">
      <h2>Preview</h2>
      <div class="canvas-wrap">
        <div style="display:grid; grid-template-columns: 1fr 1fr; gap: 12px; width:100%; height: 100%;">
          <div style="display: flex; flex-direction: column; height: 100%;">
            <div class="muted" style="margin-bottom:6px">Source</div>
            <div style="flex-grow: 1;"></div>
            <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; flex-shrink: 0;">
              <div class="video-wrapper" style="position: relative; width: 100%; max-height: 300px;">
                <video id="srcPreview" class="srcPrev" muted playsinline style="width:100%; max-height:300px; object-fit: contain;"></video>
              </div>
              <div class="video-controls" style="width: 100%; margin-top: 8px; display: grid; grid-template-columns: 1fr 8fr 1fr; align-items: center;">
                <div class="playback-controls" style="display: flex; gap: 8px;">
                  <button class="play-pause-btn btn-ghost" disabled>Play</button>
                </div>
                <div class="timeline-container">
                  <div class="timeline">
                    <div class="timeline-marker start-marker" title="Start Time"></div>
                    <div class="timeline-marker end-marker" title="End Time"></div>
                    <div class="playhead"></div>
                  </div>
                  <div class="marker-times">
                    <span class="start-time">0:00</span>
                    <span class="duration-time"></span>
                    <span class="end-time">0:00</span>
                  </div>
                </div>
              </div>
            </div>
            <div style="flex-grow: 1;"></div>
            <div class="meta-inset" style="margin-top:8px; padding:8px 10px; background:var(--bg); border:1px solid var(--border); border-radius:8px; font-size:12px;">
              <div class="muted" style="font-weight:600; margin-bottom:4px; font-size:11px; text-transform:uppercase; letter-spacing:0.05em;">Source File Info</div>
              <div class="meta" id="meta" style="display:grid;grid-template-columns:1fr 1fr;gap:8px 12px;">
                <span class="muted">Type: <span id="metaType">—</span></span>
                <span class="muted">Resolution: <span id="metaRes">—</span></span>
                <span class="muted">Framerate: <span id="metaFps">—</span></span>
                <span class="muted">Filesize: <span id="metaSize">—</span></span>
                <span class="muted">Duration: <span id="metaDur">—</span></span>
              </div>
            </div>
          </div>
          <div style="display: flex; flex-direction: column; height: 100%;">
            <div class="muted" style="margin-bottom:6px">Output</div>
            <div style="flex-grow: 1;"></div>
            <div class="preview" id="preview" style="min-height: 300px; flex-shrink: 0; display: flex; align-items: center; justify-content: center;">
              <div class="hint">GIF preview will appear here</div>
            </div>
            <div style="flex-grow: 1;"></div>
            <div class="output-meta-inset" id="outputMetaInset" style="margin-top:8px; padding:8px 10px; background:var(--bg); border:1px solid var(--border); border-radius:8px; font-size:12px;">
              <div class="muted" style="font-weight:600; margin-bottom:4px; font-size:11px; text-transform:uppercase; letter-spacing:0.05em;">Generated File Info</div>
              <div class="output-meta" style="display:grid;grid-template-columns:1fr 1fr;gap:8px 12px;">
                <span class="muted">Type: <span id="outputType">—</span></span>
                <span class="muted">Resolution: <span id="outputRes">—</span></span>
                <span class="muted">Framerate: <span id="outputFps">—</span></span>
                <span class="muted">Filesize: <span id="outputSize">—</span></span>
                <span class="muted">Duration: <span id="outputDur">—</span></span>
                <span class="muted">Encoder: <span id="outputEncoder">—</span></span>
              </div>
            </div>
          </div>
        </div>
      </div>
      <div class="toolbar" style="display:flex; gap:8px; flex-wrap:wrap; padding: 12px 14px; border-top: 1px solid var(--border); align-items: center;">
        <div id="status" class="status">
          <span class="badge ok" id="statusBadge">Ready</span>
          <span id="statusText" class="muted">Waiting for a video…</span>
        </div>
        <div class="grow" style="flex:1 1 auto"></div>
        <div style="min-width:200px">
          <div class="progress" aria-label="Progress">
            <div id="bar" class="bar"></div>
          </div>
        </div>
        <button id="downloadBtn" class="btn-ghost" disabled>Download</button>
      </div>
    </section>
  </main>

  <!-- Hidden work elements -->
  <video id="video" playsinline muted style="display:none"></video>
  <canvas id="canvas" style="display:none"></canvas>

  <!-- gif.js library -->
  <script>
// gif.js 0.2.0 - https://github.com/jnordberg/gif.js
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.GIF=f()}})(function(){var define,module,exports;return function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s}({1:[function(require,module,exports){function EventEmitter(){this._events=this._events||{};this._maxListeners=this._maxListeners||undefined}module.exports=EventEmitter;EventEmitter.EventEmitter=EventEmitter;EventEmitter.prototype._events=undefined;EventEmitter.prototype._maxListeners=undefined;EventEmitter.defaultMaxListeners=10;EventEmitter.prototype.setMaxListeners=function(n){if(!isNumber(n)||n<0||isNaN(n))throw TypeError("n must be a positive number");this._maxListeners=n;return this};EventEmitter.prototype.emit=function(type){var er,handler,len,args,i,listeners;if(!this._events)this._events={};if(type==="error"){if(!this._events.error||isObject(this._events.error)&&!this._events.error.length){er=arguments[1];if(er instanceof Error){throw er}else{var err=new Error('Uncaught, unspecified "error" event. ('+er+")");err.context=er;throw err}}}handler=this._events[type];if(isUndefined(handler))return false;if(isFunction(handler)){switch(arguments.length){case 1:handler.call(this);break;case 2:handler.call(this,arguments[1]);break;case 3:handler.call(this,arguments[1],arguments[2]);break;default:args=Array.prototype.slice.call(arguments,1);handler.apply(this,args)}}else if(isObject(handler)){args=Array.prototype.slice.call(arguments,1);listeners=handler.slice();len=listeners.length;for(i=0;i<len;i++)listeners[i].apply(this,args)}return true};EventEmitter.prototype.addListener=function(type,listener){var m;if(!isFunction(listener))throw TypeError("listener must be a function");if(!this._events)this._events={};if(this._events.newListener)this.emit("newListener",type,isFunction(listener.listener)?listener.listener:listener);if(!this._events[type])this._events[type]=listener;else if(isObject(this._events[type]))this._events[type].push(listener);else this._events[type]=[this._events[type],listener];if(isObject(this._events[type])&&!this._events[type].warned){if(!isUndefined(this._maxListeners)){m=this._maxListeners}else{m=EventEmitter.defaultMaxListeners}if(m&&m>0&&this._events[type].length>m){this._events[type].warned=true;console.error("(node) warning: possible EventEmitter memory "+"leak detected. %d listeners added. "+"Use emitter.setMaxListeners() to increase limit.",this._events[type].length);if(typeof console.trace==="function"){console.trace()}}}return this};EventEmitter.prototype.on=EventEmitter.prototype.addListener;EventEmitter.prototype.once=function(type,listener){if(!isFunction(listener))throw TypeError("listener must be a function");var fired=false;function g(){this.removeListener(type,g);if(!fired){fired=true;listener.apply(this,arguments)}}g.listener=listener;this.on(type,g);return this};EventEmitter.prototype.removeListener=function(type,listener){var list,position,length,i;if(!isFunction(listener))throw TypeError("listener must be a function");if(!this._events||!this._events[type])return this;list=this._events[type];length=list.length;position=-1;if(list===listener||isFunction(list.listener)&&list.listener===listener){delete this._events[type];if(this._events.removeListener)this.emit("removeListener",type,listener)}else if(isObject(list)){for(i=length;i-- >0;){if(list[i]===listener||list[i].listener&&list[i].listener===listener){position=i;break}}if(position<0)return this;if(list.length===1){list.length=0;delete this._events[type]}else{list.splice(position,1)}if(this._events.removeListener)this.emit("removeListener",type,listener)}return this};EventEmitter.prototype.removeAllListeners=function(type){var key,listeners;if(!this._events)return this;if(!this._events.removeListener){if(arguments.length===0)this._events={};else if(this._events[type])delete this._events[type];return this}if(arguments.length===0){for(key in this._events){if(key==="removeListener")continue;this.removeAllListeners(key)}this.removeAllListeners("removeListener");this._events={};return this}listeners=this._events[type];if(isFunction(listeners)){this.removeListener(type,listeners)}else if(listeners){while(listeners.length)this.removeListener(type,listeners[listeners.length-1])}delete this._events[type];return this};EventEmitter.prototype.listeners=function(type){var ret;if(!this._events||!this._events[type])ret=[];else if(isFunction(this._events[type]))ret=[this._events[type]];else ret=this._events[type].slice();return ret};EventEmitter.prototype.listenerCount=function(type){if(this._events){var evlistener=this._events[type];if(isFunction(evlistener))return 1;else if(evlistener)return evlistener.length}return 0};EventEmitter.listenerCount=function(emitter,type){return emitter.listenerCount(type)};function isFunction(arg){return typeof arg==="function"}function isNumber(arg){return typeof arg==="number"}function isObject(arg){return typeof arg==="object"&&arg!==null}function isUndefined(arg){return arg===void 0}},{}],2:[function(require,module,exports){var UA,browser,mode,platform,ua;ua=navigator.userAgent.toLowerCase();platform=navigator.platform.toLowerCase();UA=ua.match(/(opera|ie|firefox|chrome|version)[\s\/:]([\w\d\.]+)?.*?(safari|version[\s\/:]([\w\d\.]+)|$)/)||[null,"unknown",0];mode=UA[1]==="ie"&&document.documentMode;browser={name:UA[1]==="version"?UA[3]:UA[1],version:mode||parseFloat(UA[1]==="opera"&&UA[4]?UA[4]:UA[2]),platform:{name:ua.match(/ip(?:ad|od|hone)/)?"ios":(ua.match(/(?:webos|android)/)||platform.match(/mac|win|linux/)||["other"])[0]}};browser[browser.name]=true;browser[browser.name+parseInt(browser.version,10)]=true;browser.platform[browser.platform.name]=true;module.exports=browser},{}],3:[function(require,module,exports){var EventEmitter,GIF,browser,extend=function(child,parent){for(var key in parent){if(hasProp.call(parent,key))child[key]=parent[key]}function ctor(){this.constructor=child}ctor.prototype=parent.prototype;child.prototype=new ctor;child.__super__=parent.prototype;return child},hasProp={}.hasOwnProperty,indexOf=[].indexOf||function(item){for(var i=0,l=this.length;i<l;i++){if(i in this&&this[i]===item)return i}return-1},slice=[].slice;EventEmitter=require("events").EventEmitter;browser=require("./browser.coffee");GIF=function(superClass){var defaults,frameDefaults;extend(GIF,superClass);defaults={workerScript:"gif.worker.js",workers:2,repeat:0,background:"#fff",quality:10,width:null,height:null,transparent:null,debug:false,dither:false};frameDefaults={delay:500,copy:false};function GIF(options){var base,key,value;this.running=false;this.options={};this.frames=[];this.freeWorkers=[];this.activeWorkers=[];this.setOptions(options);for(key in defaults){value=defaults[key];if((base=this.options)[key]==null){base[key]=value}}}GIF.prototype.setOption=function(key,value){this.options[key]=value;if(this._canvas!=null&&(key==="width"||key==="height")){return this._canvas[key]=value}};GIF.prototype.setOptions=function(options){var key,results,value;results=[];for(key in options){if(!hasProp.call(options,key))continue;value=options[key];results.push(this.setOption(key,value))}return results};GIF.prototype.addFrame=function(image,options){var frame,key;if(options==null){options={}}frame={};frame.transparent=this.options.transparent;for(key in frameDefaults){frame[key]=options[key]||frameDefaults[key]}if(this.options.width==null){this.setOption("width",image.width)}if(this.options.height==null){this.setOption("height",image.height)}if(typeof ImageData!=="undefined"&&ImageData!==null&&image instanceof ImageData){frame.data=image.data}else if(typeof CanvasRenderingContext2D!=="undefined"&&CanvasRenderingContext2D!==null&&image instanceof CanvasRenderingContext2D||typeof WebGLRenderingContext!=="undefined"&&WebGLRenderingContext!==null&&image instanceof WebGLRenderingContext){if(options.copy){frame.data=this.getContextData(image)}else{frame.context=image}}else if(image.childNodes!=null){if(options.copy){frame.data=this.getImageData(image)}else{frame.image=image}}else{throw new Error("Invalid image")}return this.frames.push(frame)};GIF.prototype.render=function(){var i,j,numWorkers,ref;if(this.running){throw new Error("Already running")}if(this.options.width==null||this.options.height==null){throw new Error("Width and height must be set prior to rendering")}this.running=true;this.nextFrame=0;this.finishedFrames=0;this.imageParts=function(){var j,ref,results;results=[];for(i=j=0,ref=this.frames.length;0<=ref?j<ref:j>ref;i=0<=ref?++j:--j){results.push(null)}return results}.call(this);numWorkers=this.spawnWorkers();if(this.options.globalPalette===true){this.renderNextFrame()}else{for(i=j=0,ref=numWorkers;0<=ref?j<ref:j>ref;i=0<=ref?++j:--j){this.renderNextFrame()}}this.emit("start");return this.emit("progress",0)};GIF.prototype.abort=function(){var worker;while(true){worker=this.activeWorkers.shift();if(worker==null){break}this.log("killing active worker");worker.terminate()}this.running=false;return this.emit("abort")};GIF.prototype.spawnWorkers=function(){var j,numWorkers,ref,results;numWorkers=Math.min(this.options.workers,this.frames.length);(function(){results=[];for(var j=ref=this.freeWorkers.length;ref<=numWorkers?j<numWorkers:j>numWorkers;ref<=numWorkers?j++:j--){results.push(j)}return results}).apply(this).forEach(function(_this){return function(i){var worker;_this.log("spawning worker "+i);worker=new Worker(_this.options.workerScript);worker.onmessage=function(event){_this.activeWorkers.splice(_this.activeWorkers.indexOf(worker),1);_this.freeWorkers.push(worker);return _this.frameFinished(event.data)};return _this.freeWorkers.push(worker)}}(this));return numWorkers};GIF.prototype.frameFinished=function(frame){var i,j,ref;this.log("frame "+frame.index+" finished - "+this.activeWorkers.length+" active");this.finishedFrames++;this.emit("progress",this.finishedFrames/this.frames.length);this.imageParts[frame.index]=frame;if(this.options.globalPalette===true){this.options.globalPalette=frame.globalPalette;this.log("global palette analyzed");if(this.frames.length>2){for(i=j=1,ref=this.freeWorkers.length;1<=ref?j<ref:j>ref;i=1<=ref?++j:--j){this.renderNextFrame()}}}if(indexOf.call(this.imageParts,null)>=0){return this.renderNextFrame()}else{return this.finishRendering()}};GIF.prototype.finishRendering=function(){var data,frame,i,image,j,k,l,len,len1,len2,len3,offset,page,ref,ref1,ref2;len=0;ref=this.imageParts;for(j=0,len1=ref.length;j<len1;j++){frame=ref[j];len+=(frame.data.length-1)*frame.pageSize+frame.cursor}len+=frame.pageSize-frame.cursor;this.log("rendering finished - filesize "+Math.round(len/1e3)+"kb");data=new Uint8Array(len);offset=0;ref1=this.imageParts;for(k=0,len2=ref1.length;k<len2;k++){frame=ref1[k];ref2=frame.data;for(i=l=0,len3=ref2.length;l<len3;i=++l){page=ref2[i];data.set(page,offset);if(i===frame.data.length-1){offset+=frame.cursor}else{offset+=frame.pageSize}}}image=new Blob([data],{type:"image/gif"});return this.emit("finished",image,data)};GIF.prototype.renderNextFrame=function(){var frame,task,worker;if(this.freeWorkers.length===0){throw new Error("No free workers")}if(this.nextFrame>=this.frames.length){return}frame=this.frames[this.nextFrame++];worker=this.freeWorkers.shift();task=this.getTask(frame);this.log("starting frame "+(task.index+1)+" of "+this.frames.length);this.activeWorkers.push(worker);return worker.postMessage(task)};GIF.prototype.getContextData=function(ctx){return ctx.getImageData(0,0,this.options.width,this.options.height).data};GIF.prototype.getImageData=function(image){var ctx;if(this._canvas==null){this._canvas=document.createElement("canvas");this._canvas.width=this.options.width;this._canvas.height=this.options.height}ctx=this._canvas.getContext("2d");ctx.setFill=this.options.background;ctx.fillRect(0,0,this.options.width,this.options.height);ctx.drawImage(image,0,0);return this.getContextData(ctx)};GIF.prototype.getTask=function(frame){var index,task;index=this.frames.indexOf(frame);task={index:index,last:index===this.frames.length-1,delay:frame.delay,transparent:frame.transparent,width:this.options.width,height:this.options.height,quality:this.options.quality,dither:this.options.dither,globalPalette:this.options.globalPalette,repeat:this.options.repeat,canTransfer:browser.name==="chrome"};if(frame.data!=null){task.data=frame.data}else if(frame.context!=null){task.data=this.getContextData(frame.context)}else if(frame.image!=null){task.data=this.getImageData(frame.image)}else{throw new Error("Invalid frame")}return task};GIF.prototype.log=function(){var args;args=1<=arguments.length?slice.call(arguments,0):[];if(!this.options.debug){return}return console.log.apply(console,args)};return GIF}(EventEmitter);module.exports=GIF},{"./browser.coffee":2,events:1}]},{},[3])(3)});

// Create worker blob URL for gif.js
window._gifWorkerURL = (function() {
  const workerCode = `// gif.worker.js 0.2.0 - https://github.com/jnordberg/gif.js
(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){var NeuQuant=require("./TypedNeuQuant.js");var LZWEncoder=require("./LZWEncoder.js");function ByteArray(){this.page=-1;this.pages=[];this.newPage()}ByteArray.pageSize=4096;ByteArray.charMap={};for(var i=0;i<256;i++)ByteArray.charMap[i]=String.fromCharCode(i);ByteArray.prototype.newPage=function(){this.pages[++this.page]=new Uint8Array(ByteArray.pageSize);this.cursor=0};ByteArray.prototype.getData=function(){var rv="";for(var p=0;p<this.pages.length;p++){for(var i=0;i<ByteArray.pageSize;i++){rv+=ByteArray.charMap[this.pages[p][i]]}}return rv};ByteArray.prototype.writeByte=function(val){if(this.cursor>=ByteArray.pageSize)this.newPage();this.pages[this.page][this.cursor++]=val};ByteArray.prototype.writeUTFBytes=function(string){for(var l=string.length,i=0;i<l;i++)this.writeByte(string.charCodeAt(i))};ByteArray.prototype.writeBytes=function(array,offset,length){for(var l=length||array.length,i=offset||0;i<l;i++)this.writeByte(array[i])};function GIFEncoder(width,height){this.width=~~width;this.height=~~height;this.transparent=null;this.transIndex=0;this.repeat=-1;this.delay=0;this.image=null;this.pixels=null;this.indexedPixels=null;this.colorDepth=null;this.colorTab=null;this.neuQuant=null;this.usedEntry=new Array;this.palSize=7;this.dispose=-1;this.firstFrame=true;this.sample=10;this.dither=false;this.globalPalette=false;this.out=new ByteArray}GIFEncoder.prototype.setDelay=function(milliseconds){this.delay=Math.round(milliseconds/10)};GIFEncoder.prototype.setFrameRate=function(fps){this.delay=Math.round(100/fps)};GIFEncoder.prototype.setDispose=function(disposalCode){if(disposalCode>=0)this.dispose=disposalCode};GIFEncoder.prototype.setRepeat=function(repeat){this.repeat=repeat};GIFEncoder.prototype.setTransparent=function(color){this.transparent=color};GIFEncoder.prototype.addFrame=function(imageData){this.image=imageData;this.colorTab=this.globalPalette&&this.globalPalette.slice?this.globalPalette:null;this.getImagePixels();this.analyzePixels();if(this.globalPalette===true)this.globalPalette=this.colorTab;if(this.firstFrame){this.writeLSD();this.writePalette();if(this.repeat>=0){this.writeNetscapeExt()}}this.writeGraphicCtrlExt();this.writeImageDesc();if(!this.firstFrame&&!this.globalPalette)this.writePalette();this.writePixels();this.firstFrame=false};GIFEncoder.prototype.finish=function(){this.out.writeByte(59)};GIFEncoder.prototype.setQuality=function(quality){if(quality<1)quality=1;this.sample=quality};GIFEncoder.prototype.setDither=function(dither){if(dither===true)dither="FloydSteinberg";this.dither=dither};GIFEncoder.prototype.setGlobalPalette=function(palette){this.globalPalette=palette};GIFEncoder.prototype.getGlobalPalette=function(){return this.globalPalette&&this.globalPalette.slice&&this.globalPalette.slice(0)||this.globalPalette};GIFEncoder.prototype.writeHeader=function(){this.out.writeUTFBytes("GIF89a")};GIFEncoder.prototype.analyzePixels=function(){if(!this.colorTab){this.neuQuant=new NeuQuant(this.pixels,this.sample);this.neuQuant.buildColormap();this.colorTab=this.neuQuant.getColormap()}if(this.dither){this.ditherPixels(this.dither.replace("-serpentine",""),this.dither.match(/-serpentine/)!==null)}else{this.indexPixels()}this.pixels=null;this.colorDepth=8;this.palSize=7;if(this.transparent!==null){this.transIndex=this.findClosest(this.transparent,true)}};GIFEncoder.prototype.indexPixels=function(imgq){var nPix=this.pixels.length/3;this.indexedPixels=new Uint8Array(nPix);var k=0;for(var j=0;j<nPix;j++){var index=this.findClosestRGB(this.pixels[k++]&255,this.pixels[k++]&255,this.pixels[k++]&255);this.usedEntry[index]=true;this.indexedPixels[j]=index}};GIFEncoder.prototype.ditherPixels=function(kernel,serpentine){var kernels={FalseFloydSteinberg:[[3/8,1,0],[3/8,0,1],[2/8,1,1]],FloydSteinberg:[[7/16,1,0],[3/16,-1,1],[5/16,0,1],[1/16,1,1]],Stucki:[[8/42,1,0],[4/42,2,0],[2/42,-2,1],[4/42,-1,1],[8/42,0,1],[4/42,1,1],[2/42,2,1],[1/42,-2,2],[2/42,-1,2],[4/42,0,2],[2/42,1,2],[1/42,2,2]],Atkinson:[[1/8,1,0],[1/8,2,0],[1/8,-1,1],[1/8,0,1],[1/8,1,1],[1/8,0,2]]};if(!kernel||!kernels[kernel]){throw"Unknown dithering kernel: "+kernel}var ds=kernels[kernel];var index=0,height=this.height,width=this.width,data=this.pixels;var direction=serpentine?-1:1;this.indexedPixels=new Uint8Array(this.pixels.length/3);for(var y=0;y<height;y++){if(serpentine)direction=direction*-1;for(var x=direction==1?0:width-1,xend=direction==1?width:0;x!==xend;x+=direction){index=y*width+x;var idx=index*3;var r1=data[idx];var g1=data[idx+1];var b1=data[idx+2];idx=this.findClosestRGB(r1,g1,b1);this.usedEntry[idx]=true;this.indexedPixels[index]=idx;idx*=3;var r2=this.colorTab[idx];var g2=this.colorTab[idx+1];var b2=this.colorTab[idx+2];var er=r1-r2;var eg=g1-g2;var eb=b1-b2;for(var i=direction==1?0:ds.length-1,end=direction==1?ds.length:0;i!==end;i+=direction){var x1=ds[i][1];var y1=ds[i][2];if(x1+x>=0&&x1+x<width&&y1+y>=0&&y1+y<height){var d=ds[i][0];idx=index+x1+y1*width;idx*=3;data[idx]=Math.max(0,Math.min(255,data[idx]+er*d));data[idx+1]=Math.max(0,Math.min(255,data[idx+1]+eg*d));data[idx+2]=Math.max(0,Math.min(255,data[idx+2]+eb*d))}}}}};GIFEncoder.prototype.findClosest=function(c,used){return this.findClosestRGB((c&16711680)>>16,(c&65280)>>8,c&255,used)};GIFEncoder.prototype.findClosestRGB=function(r,g,b,used){if(this.colorTab===null)return-1;if(this.neuQuant&&!used){return this.neuQuant.lookupRGB(r,g,b)}var c=b|g<<8|r<<16;var minpos=0;var dmin=256*256*256;var len=this.colorTab.length;for(var i=0,index=0;i<len;index++){var dr=r-(this.colorTab[i++]&255);var dg=g-(this.colorTab[i++]&255);var db=b-(this.colorTab[i++]&255);var d=dr*dr+dg*dg+db*db;if((!used||this.usedEntry[index])&&d<dmin){dmin=d;minpos=index}}return minpos};GIFEncoder.prototype.getImagePixels=function(){var w=this.width;var h=this.height;this.pixels=new Uint8Array(w*h*3);var data=this.image;var srcPos=0;var count=0;for(var i=0;i<h;i++){for(var j=0;j<w;j++){this.pixels[count++]=data[srcPos++];this.pixels[count++]=data[srcPos++];this.pixels[count++]=data[srcPos++];srcPos++}}};GIFEncoder.prototype.writeGraphicCtrlExt=function(){this.out.writeByte(33);this.out.writeByte(249);this.out.writeByte(4);var transp,disp;if(this.transparent===null){transp=0;disp=0}else{transp=1;disp=2}if(this.dispose>=0){disp=dispose&7}disp<<=2;this.out.writeByte(0|disp|0|transp);this.writeShort(this.delay);this.out.writeByte(this.transIndex);this.out.writeByte(0)};GIFEncoder.prototype.writeImageDesc=function(){this.out.writeByte(44);this.writeShort(0);this.writeShort(0);this.writeShort(this.width);this.writeShort(this.height);if(this.firstFrame||this.globalPalette){this.out.writeByte(0)}else{this.out.writeByte(128|0|0|0|this.palSize)}};GIFEncoder.prototype.writeLSD=function(){this.writeShort(this.width);this.writeShort(this.height);this.out.writeByte(128|112|0|this.palSize);this.out.writeByte(0);this.out.writeByte(0)};GIFEncoder.prototype.writeNetscapeExt=function(){this.out.writeByte(33);this.out.writeByte(255);this.out.writeByte(11);this.out.writeUTFBytes("NETSCAPE2.0");this.out.writeByte(3);this.out.writeByte(1);this.writeShort(this.repeat);this.out.writeByte(0)};GIFEncoder.prototype.writePalette=function(){this.out.writeBytes(this.colorTab);var n=3*256-this.colorTab.length;for(var i=0;i<n;i++)this.out.writeByte(0)};GIFEncoder.prototype.writeShort=function(pValue){this.out.writeByte(pValue&255);this.out.writeByte(pValue>>8&255)};GIFEncoder.prototype.writePixels=function(){var enc=new LZWEncoder(this.width,this.height,this.indexedPixels,this.colorDepth);enc.encode(this.out)};GIFEncoder.prototype.stream=function(){return this.out};module.exports=GIFEncoder},{"./LZWEncoder.js":2,"./TypedNeuQuant.js":3}],2:[function(require,module,exports){var EOF=-1;var BITS=12;var HSIZE=5003;var masks=[0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535];function LZWEncoder(width,height,pixels,colorDepth){var initCodeSize=Math.max(2,colorDepth);var accum=new Uint8Array(256);var htab=new Int32Array(HSIZE);var codetab=new Int32Array(HSIZE);var cur_accum,cur_bits=0;var a_count;var free_ent=0;var maxcode;var clear_flg=false;var g_init_bits,ClearCode,EOFCode;function char_out(c,outs){accum[a_count++]=c;if(a_count>=254)flush_char(outs)}function cl_block(outs){cl_hash(HSIZE);free_ent=ClearCode+2;clear_flg=true;output(ClearCode,outs)}function cl_hash(hsize){for(var i=0;i<hsize;++i)htab[i]=-1}function compress(init_bits,outs){var fcode,c,i,ent,disp,hsize_reg,hshift;g_init_bits=init_bits;clear_flg=false;n_bits=g_init_bits;maxcode=MAXCODE(n_bits);ClearCode=1<<init_bits-1;EOFCode=ClearCode+1;free_ent=ClearCode+2;a_count=0;ent=nextPixel();hshift=0;for(fcode=HSIZE;fcode<65536;fcode*=2)++hshift;hshift=8-hshift;hsize_reg=HSIZE;cl_hash(hsize_reg);output(ClearCode,outs);outer_loop:while((c=nextPixel())!=EOF){fcode=(c<<BITS)+ent;i=c<<hshift^ent;if(htab[i]===fcode){ent=codetab[i];continue}else if(htab[i]>=0){disp=hsize_reg-i;if(i===0)disp=1;do{if((i-=disp)<0)i+=hsize_reg;if(htab[i]===fcode){ent=codetab[i];continue outer_loop}}while(htab[i]>=0)}output(ent,outs);ent=c;if(free_ent<1<<BITS){codetab[i]=free_ent++;htab[i]=fcode}else{cl_block(outs)}}output(ent,outs);output(EOFCode,outs)}function encode(outs){outs.writeByte(initCodeSize);remaining=width*height;curPixel=0;compress(initCodeSize+1,outs);outs.writeByte(0)}function flush_char(outs){if(a_count>0){outs.writeByte(a_count);outs.writeBytes(accum,0,a_count);a_count=0}}function MAXCODE(n_bits){return(1<<n_bits)-1}function nextPixel(){if(remaining===0)return EOF;--remaining;var pix=pixels[curPixel++];return pix&255}function output(code,outs){cur_accum&=masks[cur_bits];if(cur_bits>0)cur_accum|=code<<cur_bits;else cur_accum=code;cur_bits+=n_bits;while(cur_bits>=8){char_out(cur_accum&255,outs);cur_accum>>=8;cur_bits-=8}if(free_ent>maxcode||clear_flg){if(clear_flg){maxcode=MAXCODE(n_bits=g_init_bits);clear_flg=false}else{++n_bits;if(n_bits==BITS)maxcode=1<<BITS;else maxcode=MAXCODE(n_bits)}}if(code==EOFCode){while(cur_bits>0){char_out(cur_accum&255,outs);cur_accum>>=8;cur_bits-=8}flush_char(outs)}}this.encode=encode}module.exports=LZWEncoder},{}],3:[function(require,module,exports){var ncycles=100;var netsize=256;var maxnetpos=netsize-1;var netbiasshift=4;var intbiasshift=16;var intbias=1<<intbiasshift;var gammashift=10;var gamma=1<<gammashift;var betashift=10;var beta=intbias>>betashift;var betagamma=intbias<<gammashift-betashift;var initrad=netsize>>3;var radiusbiasshift=6;var radiusbias=1<<radiusbiasshift;var initradius=initrad*radiusbias;var radiusdec=30;var alphabiasshift=10;var initalpha=1<<alphabiasshift;var alphadec;var radbiasshift=8;var radbias=1<<radbiasshift;var alpharadbshift=alphabiasshift+radbiasshift;var alpharadbias=1<<alpharadbshift;var prime1=499;var prime2=491;var prime3=487;var prime4=503;var minpicturebytes=3*prime4;function NeuQuant(pixels,samplefac){var network;var netindex;var bias;var freq;var radpower;function init(){network=[];netindex=new Int32Array(256);bias=new Int32Array(netsize);freq=new Int32Array(netsize);radpower=new Int32Array(netsize>>3);var i,v;for(i=0;i<netsize;i++){v=(i<<netbiasshift+8)/netsize;network[i]=new Float64Array([v,v,v,0]);freq[i]=intbias/netsize;bias[i]=0}}function unbiasnet(){for(var i=0;i<netsize;i++){network[i][0]>>=netbiasshift;network[i][1]>>=netbiasshift;network[i][2]>>=netbiasshift;network[i][3]=i}}function altersingle(alpha,i,b,g,r){network[i][0]-=alpha*(network[i][0]-b)/initalpha;network[i][1]-=alpha*(network[i][1]-g)/initalpha;network[i][2]-=alpha*(network[i][2]-r)/initalpha}function alterneigh(radius,i,b,g,r){var lo=Math.abs(i-radius);var hi=Math.min(i+radius,netsize);var j=i+1;var k=i-1;var m=1;var p,a;while(j<hi||k>lo){a=radpower[m++];if(j<hi){p=network[j++];p[0]-=a*(p[0]-b)/alpharadbias;p[1]-=a*(p[1]-g)/alpharadbias;p[2]-=a*(p[2]-r)/alpharadbias}if(k>lo){p=network[k--];p[0]-=a*(p[0]-b)/alpharadbias;p[1]-=a*(p[1]-g)/alpharadbias;p[2]-=a*(p[2]-r)/alpharadbias}}}function contest(b,g,r){var bestd=~(1<<31);var bestbiasd=bestd;var bestpos=-1;var bestbiaspos=bestpos;var i,n,dist,biasdist,betafreq;for(i=0;i<netsize;i++){n=network[i];dist=Math.abs(n[0]-b)+Math.abs(n[1]-g)+Math.abs(n[2]-r);if(dist<bestd){bestd=dist;bestpos=i}biasdist=dist-(bias[i]>>intbiasshift-netbiasshift);if(biasdist<bestbiasd){bestbiasd=biasdist;bestbiaspos=i}betafreq=freq[i]>>betashift;freq[i]-=betafreq;bias[i]+=betafreq<<gammashift}freq[bestpos]+=beta;bias[bestpos]-=betagamma;return bestbiaspos}function inxbuild(){var i,j,p,q,smallpos,smallval,previouscol=0,startpos=0;for(i=0;i<netsize;i++){p=network[i];smallpos=i;smallval=p[1];for(j=i+1;j<netsize;j++){q=network[j];if(q[1]<smallval){smallpos=j;smallval=q[1]}}q=network[smallpos];if(i!=smallpos){j=q[0];q[0]=p[0];p[0]=j;j=q[1];q[1]=p[1];p[1]=j;j=q[2];q[2]=p[2];p[2]=j;j=q[3];q[3]=p[3];p[3]=j}if(smallval!=previouscol){netindex[previouscol]=startpos+i>>1;for(j=previouscol+1;j<smallval;j++)netindex[j]=i;previouscol=smallval;startpos=i}}netindex[previouscol]=startpos+maxnetpos>>1;for(j=previouscol+1;j<256;j++)netindex[j]=maxnetpos}function inxsearch(b,g,r){var a,p,dist;var bestd=1e3;var best=-1;var i=netindex[g];var j=i-1;while(i<netsize||j>=0){if(i<netsize){p=network[i];dist=p[1]-g;if(dist>=bestd)i=netsize;else{i++;if(dist<0)dist=-dist;a=p[0]-b;if(a<0)a=-a;dist+=a;if(dist<bestd){a=p[2]-r;if(a<0)a=-a;dist+=a;if(dist<bestd){bestd=dist;best=p[3]}}}}if(j>=0){p=network[j];dist=g-p[1];if(dist>=bestd)j=-1;else{j--;if(dist<0)dist=-dist;a=p[0]-b;if(a<0)a=-a;dist+=a;if(dist<bestd){a=p[2]-r;if(a<0)a=-a;dist+=a;if(dist<bestd){bestd=dist;best=p[3]}}}}}return best}function learn(){var i;var lengthcount=pixels.length;var alphadec=30+(samplefac-1)/3;var samplepixels=lengthcount/(3*samplefac);var delta=~~(samplepixels/ncycles);var alpha=initalpha;var radius=initradius;var rad=radius>>radiusbiasshift;if(rad<=1)rad=0;for(i=0;i<rad;i++)radpower[i]=alpha*((rad*rad-i*i)*radbias/(rad*rad));var step;if(lengthcount<minpicturebytes){samplefac=1;step=3}else if(lengthcount%prime1!==0){step=3*prime1}else if(lengthcount%prime2!==0){step=3*prime2}else if(lengthcount%prime3!==0){step=3*prime3}else{step=3*prime4}var b,g,r,j;var pix=0;i=0;while(i<samplepixels){b=(pixels[pix]&255)<<netbiasshift;g=(pixels[pix+1]&255)<<netbiasshift;r=(pixels[pix+2]&255)<<netbiasshift;j=contest(b,g,r);altersingle(alpha,j,b,g,r);if(rad!==0)alterneigh(rad,j,b,g,r);pix+=step;if(pix>=lengthcount)pix-=lengthcount;i++;if(delta===0)delta=1;if(i%delta===0){alpha-=alpha/alphadec;radius-=radius/radiusdec;rad=radius>>radiusbiasshift;if(rad<=1)rad=0;for(j=0;j<rad;j++)radpower[j]=alpha*((rad*rad-j*j)*radbias/(rad*rad))}}}function buildColormap(){init();learn();unbiasnet();inxbuild()}this.buildColormap=buildColormap;function getColormap(){var map=[];var index=[];for(var i=0;i<netsize;i++)index[network[i][3]]=i;var k=0;for(var l=0;l<netsize;l++){var j=index[l];map[k++]=network[j][0];map[k++]=network[j][1];map[k++]=network[j][2]}return map}this.getColormap=getColormap;this.lookupRGB=inxsearch}module.exports=NeuQuant},{}],4:[function(require,module,exports){var GIFEncoder,renderFrame;GIFEncoder=require("./GIFEncoder.js");renderFrame=function(frame){var encoder,page,stream,transfer;encoder=new GIFEncoder(frame.width,frame.height);if(frame.index===0){encoder.writeHeader()}else{encoder.firstFrame=false}encoder.setTransparent(frame.transparent);encoder.setRepeat(frame.repeat);encoder.setDelay(frame.delay);encoder.setQuality(frame.quality);encoder.setDither(frame.dither);encoder.setGlobalPalette(frame.globalPalette);encoder.addFrame(frame.data);if(frame.last){encoder.finish()}if(frame.globalPalette===true){frame.globalPalette=encoder.getGlobalPalette()}stream=encoder.stream();frame.data=stream.pages;frame.cursor=stream.cursor;frame.pageSize=stream.constructor.pageSize;if(frame.canTransfer){transfer=function(){var i,len,ref,results;ref=frame.data;results=[];for(i=0,len=ref.length;i<len;i++){page=ref[i];results.push(page.buffer)}return results}();return self.postMessage(frame,transfer)}else{return self.postMessage(frame)}};self.onmessage=function(event){return renderFrame(event.data)}},{"./GIFEncoder.js":1}]},{},[4]);`;
  
  const blob = new Blob([workerCode], { type: 'application/javascript' });
  return URL.createObjectURL(blob);
})();
  </script>
  <script src="js/ffmpeg.min.js"></script>

  <script>
  // ---------- UI Helpers ----------
  const el = id => document.getElementById(id);
  const fileInput = el('fileInput');
  const drop = el('drop');
  const preview = el('preview');
  const goBtn = el('goBtn');
  const resetBtn = el('resetBtn');
  const bar = el('bar');
  const status = el('status');
  const statusBadge = document.getElementById('statusBadge');
  const statusText = document.getElementById('statusText');
  const metaType = el('metaType');
  const metaRes = el('metaRes');
  const metaFps = el('metaFps');
  const metaSize = el('metaSize');
  const metaDur = el('metaDur');
  const fpsSeg = el('fpsSeg');
  const scaleSeg = el('scaleSeg');
  const startTimeInput = el('startTime');
  const endTimeInput = el('endTime');
  const devPanel = el('devPanel');
  const devGlobal = el('devGlobal');
  const devDitherS = el('devDitherS');
  const devDitherSV = el('devDitherSV');
  const devSampleCap = el('devSampleCap');
  const devPixStep = el('devPixStep');
  const devToggleBtn = el('devToggleBtn');
  const devLog = el('devLog');
  const palPresetSeg = el('palPresetSeg');
  const palQuality = el('palQuality');
  const webpBtn = el('webpBtn');
  const webmBtn = el('webmBtn');
  const srcPreview = el('srcPreview');
  const encoderSeg = el('encoderSeg');
  const ditherSelect = el('ditherSelect');
  const downloadBtn = el('downloadBtn');
  const outputMetaInset = el('outputMetaInset');
  const outputType = el('outputType');
  const outputRes = el('outputRes');
  const outputFps = el('outputFps');
  const outputSize = el('outputSize');
  const outputDur = el('outputDur');
  const outputEncoder = el('outputEncoder');

  const FPS_OPTIONS = [5, 10, 12.5, 15, 30, 60];
  const SCALE_OPTIONS = [0.25, 0.5, 0.75, 1];
  let chosenFps = 30; // default
  let chosenScale = 1; // default
  const PALETTE_PRESETS = [{label:'Fast', v:20}, {label:'Balanced', v:10}, {label:'Film', v:3}];
  let nqSample = 3; // NeuQuant sample factor (lower = better quality) 
  const ENCODER_OPTIONS = [{label:'gif.js', v:'gifjs'}, {label:'JavaScript', v:'js'}];
  let chosenEncoder = 'gifjs'; // default to gif.js encoder 
  let chosenDither = 'FloydSteinberg'; // default dithering method 
  // WebP export removed; quality options not needed

  // Crop functionality variables
  let cropEnabled = false;
  let cropRegion = null;
  let cropOverlay = null;
  let cropRegionElement = null;
  let resizeObserver = null; 

  function makeSeg(container, values, formatter, onSelect, defaultValue){
    values.forEach(v => {
      const b = document.createElement('button');
      b.textContent = formatter(v);
      b.dataset.value = String(v);
      if (v === defaultValue) b.classList.add('active');
      b.addEventListener('click', () => {
        [...container.querySelectorAll('button')].forEach(x => x.classList.remove('active'));
        b.classList.add('active');
        onSelect(v);
      });
      container.appendChild(b);
    });
  }

  makeSeg(fpsSeg, FPS_OPTIONS, v => `${v}`, v => { chosenFps = v; }, chosenFps);
  makeSeg(scaleSeg, SCALE_OPTIONS, v => `${v}x`, v => { 
    chosenScale = v; 
    if (cropEnabled) {
      updateCropDimensions();
    } else {
      updateOutputDimensions();
    }
  }, chosenScale);

  // Presets
  makeSeg(palPresetSeg, PALETTE_PRESETS.map(p=>p.v), v => PALETTE_PRESETS.find(p=>p.v===v).label, v => {
    nqSample = v;
    // Map WebP quality to preset: Fast=60, Balanced=75, Film=95
    const label = PALETTE_PRESETS.find(p=>p.v===v)?.label || '';
    if (label === 'Fast') webpQuality = 60;
    else if (label === 'Balanced') webpQuality = 75;
    else if (label === 'Film') webpQuality = 95;
  }, nqSample);

  // Encoder options
  makeSeg(encoderSeg, ENCODER_OPTIONS.map(p=>p.v), v => ENCODER_OPTIONS.find(p=>p.v===v).label, v => {
    chosenEncoder = v;
  }, chosenEncoder);

  // WebP quality mapped to palette preset (Fast=60, Balanced=75, Film=95)
  let webpQuality = 75;

  // Dithering dropdown
  ditherSelect?.addEventListener('change', (e) => {
    chosenDither = e.target.value;
  });

  function setStatus(a, b, c){
    // Supports two forms:
    // 1) setStatus('message', progress?)
    // 2) setStatus('ok'|'warn'|'err', 'message', progress?)
    let kind = 'ok';
    let message = '';
    let progress;
    if (a === 'ok' || a === 'warn' || a === 'err'){
      kind = a;
      message = typeof b === 'string' ? b : '';
      progress = typeof b === 'number' ? b : c;
    } else {
      message = (a == null ? '' : String(a));
      progress = (typeof b === 'number') ? b : undefined;
    }
    if (statusBadge){
      statusBadge.classList.remove('ok','warn','err');
      statusBadge.classList.add(kind);
      statusBadge.textContent = kind === 'ok' ? 'Ready' : (kind === 'warn' ? 'Warning' : 'Error');
    }
    if (statusText){ statusText.textContent = message; }
    if (typeof progress === 'number'){
      const clamp = Math.max(0, Math.min(1, progress));
      if (bar) bar.style.inset = `0 ${100 - clamp*100}% 0 0`;
    }
  }

  function bytes(n){
    if (!Number.isFinite(n)) return '—';
    const units = ['B','KB','MB','GB'];
    let i=0; while(n>=1024 && i<units.length-1){ n/=1024; i++; }
    return `${n.toFixed(i?1:0)} ${units[i]}`;
  }

  function getFileType(file){
    if (!file) return '—';
    // Extract extension from filename
    const ext = file.name ? file.name.split('.').pop().toLowerCase() : '';
    // Common video extensions
    const videoTypes = {
      'mp4': 'MP4',
      'mov': 'MOV',
      'avi': 'AVI',
      'mkv': 'MKV',
      'webm': 'WebM',
      'ogv': 'OGV',
      'm4v': 'M4V',
      'wmv': 'WMV',
      'flv': 'FLV',
      '3gp': '3GP'
    };
    return videoTypes[ext] || ext.toUpperCase() || 'Video';
  }

  function clearOutput(){
    try{ if (outputUrl) URL.revokeObjectURL(outputUrl); }catch{}
    outputUrl = null; outputBlob = null; outputExt = ''; outputMime = '';
    if (downloadBtn){
      downloadBtn.disabled = true;
      downloadBtn.classList.remove('btn-primary');
      downloadBtn.classList.add('btn-ghost');
    }
    // Reset output metadata to placeholders
    if (outputType) outputType.textContent = '—';
    if (outputRes) outputRes.textContent = '—';
    if (outputFps) outputFps.textContent = '—';
    if (outputSize) outputSize.textContent = '—';
    if (outputDur) outputDur.textContent = '—';
    if (outputEncoder) outputEncoder.textContent = '—';
  }
  function setOutput(blob, ext, mime){
    clearOutput();
    outputBlob = blob; outputExt = ext || ''; outputMime = mime || (blob && blob.type) || '';
    try{ outputUrl = URL.createObjectURL(blob); }catch{ outputUrl = null; }
    if (downloadBtn){
      const ok = !!outputUrl;
      downloadBtn.disabled = !ok;
      if (ok){
        downloadBtn.classList.remove('btn-ghost');
        downloadBtn.classList.add('btn-primary');
      } else {
        downloadBtn.classList.remove('btn-primary');
        downloadBtn.classList.add('btn-ghost');
      }
    }
    return outputUrl;
  }
  
  function updateOutputMetadata(blob, type, encoder, width, height, fps, duration){
    if (!outputMetaInset) return;
    
    // Update metadata fields
    if (outputType) outputType.textContent = type || 'Unknown';
    if (outputRes && width && height) outputRes.textContent = `${width} × ${height}`;
    if (outputFps) outputFps.textContent = fps ? `${fps} fps` : '—';
    if (outputSize) outputSize.textContent = blob ? bytes(blob.size) : '—';
    if (outputDur) outputDur.textContent = duration ? `${duration.toFixed(2)} s` : '—';
    if (outputEncoder) outputEncoder.textContent = encoder || 'Unknown';
  }
  
  function getOutputFilename(){
    const base = (sourceFile && sourceFile.name) ? sourceFile.name.replace(/\.[^/.]+$/, '') : 'output';
    const ext = outputExt || (outputMime.indexOf('gif')>=0 ? 'gif' : (outputMime.indexOf('webm')>=0 ? 'webm' : 'bin'));
    return `${base}.${ext}`;
  }
  function downloadCurrent(){
    if (!outputUrl || !outputBlob) return;
    const a = document.createElement('a');
    a.href = outputUrl; a.download = getOutputFilename();
    document.body.appendChild(a); a.click(); a.remove();
  }
  downloadBtn?.addEventListener('click', downloadCurrent);

  // Capability check for WebM export
  function canExportWebM(){
    try{
      if (typeof MediaRecorder === 'undefined' || !HTMLCanvasElement.prototype.captureStream) return false;
      const types = ['video/webm;codecs=vp9','video/webm;codecs=vp8','video/webm'];
      return types.some(t => MediaRecorder.isTypeSupported ? MediaRecorder.isTypeSupported(t) : true);
    }catch{ return false; }
  }

  // Dev toggle (button + shortcut)
  function toggleDevPanel(force){
    const show = typeof force === 'boolean' ? force : (devPanel.style.display === 'none');
    devPanel.style.display = show ? 'block' : 'none';
    devToggleBtn?.setAttribute('aria-expanded', show ? 'true' : 'false');
  }
  document.addEventListener('keydown', (e)=>{
    if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'd'){
      toggleDevPanel();
    }
  });
  devToggleBtn?.addEventListener('click', ()=> toggleDevPanel());
  devDitherS?.addEventListener('input', ()=> devDitherSV.textContent = devDitherS.value);

  // ---------- Time input helpers ----------
  let duration = 0;
  
  function validateTimeInputs() {
    const start = parseFloat(startTimeInput.value);
    const end = parseFloat(endTimeInput.value);
    
    if (start >= end) {
      startTimeInput.value = (end - 0.1).toFixed(1);
    }
  }
  
  if (startTimeInput) {
    startTimeInput.addEventListener('change', validateTimeInputs);
  }
  if (endTimeInput) {
    endTimeInput.addEventListener('change', validateTimeInputs);
  }

  // ---------- Video handling ----------
  const video = el('video');
  const canvas = el('canvas');
  const ctx = canvas.getContext('2d', { willReadFrequently: true });
  let objectURL = null;
  let srcFpsEstimate = null;
  let sourceFile = null;
  // Track last generated output (for Download button)
  let outputBlob = null;
  let outputUrl = null;
  let outputExt = '';
  let outputMime = '';

  function clearPreview(){
    preview.innerHTML = '<div class="hint">GIF preview will appear here</div>';
    preview.style.display = 'flex';
    preview.style.alignItems = 'center';
    preview.style.justifyContent = 'center';
    setStatus('Waiting for a video…', 0);
  }

  function enableConvert(on){ goBtn.disabled = !on; }
  function enableReset(on){ resetBtn.disabled = !on; }

  async function handleFile(file){
    if (!file){ return; }
    sourceFile = file;
    clearOutput();
    enableReset(true);
    enableConvert(false);
    clearPreview();

    if (objectURL) URL.revokeObjectURL(objectURL);
    objectURL = URL.createObjectURL(file);

    setStatus('Loading video metadata…', 0);
    video.src = objectURL;
    video.load();
    if (srcPreview){ srcPreview.src = objectURL; srcPreview.load(); }

    await new Promise((resolve, reject) => {
      const onLoaded = () => { cleanup(); resolve(); };
      const onError = (e) => { cleanup(); reject(e); };
      const cleanup = () => {
        video.removeEventListener('loadedmetadata', onLoaded);
        video.removeEventListener('error', onError);
      };
      video.addEventListener('loadedmetadata', onLoaded);
      video.addEventListener('error', onError);
    }).catch(()=>{});

    const vw = video.videoWidth, vh = video.videoHeight;
    duration = isFinite(video.duration) ? video.duration : 0;

    metaType.textContent = getFileType(file);
    metaRes.textContent = vw && vh ? `${vw} × ${vh}` : '—';
    metaDur.textContent = duration ? `${duration.toFixed(2)} s` : '—';
    metaSize.textContent = bytes(file.size);

    // Initialize time controls
    if(startTimeInput && endTimeInput){
      const d = duration || 0;
      startTimeInput.min = '0'; endTimeInput.min = '0';
      startTimeInput.max = String(d.toFixed(2)); endTimeInput.max = String(d.toFixed(2));
      startTimeInput.step = endTimeInput.step = '0.01';
      startTimeInput.value = '0'; endTimeInput.value = String(d.toFixed(2));
    }
    
    // Initialize timeline if available
    if (timeline) {
      timeline.handleVideoLoad();
    }

    // Try to estimate source FPS using rVFC
    srcFpsEstimate = await estimateFps(video).catch(()=>null);
    metaFps.textContent = srcFpsEstimate ? `${srcFpsEstimate.toFixed(2)} fps` : '—';

    setStatus('Ready. Choose settings and click Generate WebP/WebM or Generate GIF.', 0);
    enableConvert(true);
    if (webpBtn){ webpBtn.disabled = false; }
    if (webmBtn){ webmBtn.disabled = !canExportWebM(); }
    
  }

  async function estimateFps(video){
    if (!('requestVideoFrameCallback' in HTMLVideoElement.prototype)) return null;
    return new Promise(async (resolve) => {
      try{
        await seekTo(video, Math.min(0.2, Math.max(0, video.duration * 0.02)));
        let first = null, last = null, count = 0;
        const maxSpan = Math.min(0.8, Math.max(0.4, video.duration * 0.2));
        const cb = (now, meta) => {
          if (first === null) first = meta.mediaTime;
          last = meta.mediaTime;
          count++;
          if ((last - first) >= maxSpan){
            video.pause();
            const span = Math.max(0.001, last - first);
            resolve(count / span);
          }else{
            video.requestVideoFrameCallback(cb);
          }
        };
        video.muted = true; video.playbackRate = 1.0; 
        video.requestVideoFrameCallback(cb);
        await video.play().catch(()=>resolve(null));
      }catch{ resolve(null); }
    });
  }

  function seekTo(v, t){
    return new Promise(resolve => {
      const needSeek = !(Number.isFinite(v.currentTime) && Math.abs(v.currentTime - t) < 0.0005);
      if (!needSeek){ resolve(); return; }
      let done = false;
      const finish = ()=>{ if (done) return; done = true; v.removeEventListener('seeked', onSeeked); v.removeEventListener('timeupdate', onTimeUpdate); resolve(); };
      const onSeeked = ()=> finish();
      const onTimeUpdate = ()=> { if (Math.abs(v.currentTime - t) < 0.002) finish(); };
      v.addEventListener('seeked', onSeeked);
      v.addEventListener('timeupdate', onTimeUpdate);
      try { v.currentTime = t; } catch(e) { setTimeout(finish, 50); }
      setTimeout(finish, 1200);
    });
  }



  // Drag & drop
  drop.addEventListener('dragover', e=>{ e.preventDefault(); drop.style.borderColor = '#60a5fa'; });
  drop.addEventListener('dragleave', e=>{ drop.style.borderColor = '#334155'; });
  drop.addEventListener('drop', e=>{
    e.preventDefault(); drop.style.borderColor = '#334155';
    const f = e.dataTransfer.files && e.dataTransfer.files[0];
    if (f) handleFile(f);
  });
  fileInput.addEventListener('change', e=>{
    const f = fileInput.files && fileInput.files[0];
    if (f) handleFile(f);
  });
  resetBtn.addEventListener('click', ()=>{
    fileInput.value = '';
    video.removeAttribute('src');
    if (objectURL) URL.revokeObjectURL(objectURL);
    objectURL = null; duration = 0; srcFpsEstimate = null;
    clearOutput();
    if (srcPreview){ try{ srcPreview.removeAttribute('src'); srcPreview.load(); }catch{} }
    metaType.textContent = '—'; metaRes.textContent = '—'; metaFps.textContent = '—'; metaSize.textContent = '—'; metaDur.textContent = '—';
    
    // Reset time inputs
    if (startTimeInput) startTimeInput.value = '0';
    if (endTimeInput) endTimeInput.value = '0';
    
    // Reset timeline if available
    if (timeline) {
      timeline.setTimelineEnabled(false);
    }
    
    setStatus('Waiting for a video…', 0);
    enableConvert(false); clearPreview(); enableReset(false);
    if (webpBtn){ webpBtn.disabled = true; }
    if (webmBtn){ webmBtn.disabled = true; }
    
  });

  // ---------- Palette helpers ----------
  function clamp8(v){ v = Math.round(v); return v<0?0:(v>255?255:v); }
  const bayer4 = [0,8,2,10,12,4,14,6,3,11,1,9,15,7,13,5];

  function mapImageToIndexed(img, w,h, nq, colorTab, ditherMode, strength){
    const data = img.data; const out = new Uint8Array(w*h);
    const mode = ditherMode || 'none';
    if (mode === 'floyd'){
      // Build RGB palette (convert from NeuQuant BGR)
      const pal = new Float32Array(256*3);
      for (let i=0, j=0; i<colorTab.length && j<pal.length; i+=3, j+=3){
        pal[j] = colorTab[i+2]; pal[j+1] = colorTab[i+1]; pal[j+2] = colorTab[i];
      }
      const work = new Float32Array(w*h*3);
      for (let p=0, q=0; p<data.length && q<work.length; p+=4, q+=3){
        work[q] = data[p]; work[q+1] = data[p+1]; work[q+2] = data[p+2];
      }
      const s = Math.max(0, Math.min(1, (Number(strength)||0) / 48));
      for (let y=0; y<h; y++){
        for (let x=0; x<w; x++){
          const idx = y*w + x; const off = idx*3;
          let r = work[off], g = work[off+1], b = work[off+2];
          const pi = nq.map(b,g,r);
          out[idx] = pi;
          const pr = pal[pi*3], pg = pal[pi*3+1], pb = pal[pi*3+2];
          const er = (r - pr) * s, eg = (g - pg) * s, eb = (b - pb) * s;
          // Distribute error (Floyd–Steinberg)
          const add = (xx,yy,wf)=>{
            if (xx<0||xx>=w||yy<0||yy>=h) return;
            const ii = (yy*w + xx)*3; work[ii] += er*wf; work[ii+1] += eg*wf; work[ii+2] += eb*wf;
          };
          add(x+1, y  , 7/16);
          add(x-1, y+1, 3/16);
          add(x  , y+1, 5/16);
          add(x+1, y+1, 1/16);
        }
      }
      return out;
    } else {
      let k=0;
      for (let y=0;y<h;y++){
        for (let x=0;x<w;x++,k++){
          let i = (k<<2);
          let r = data[i], g = data[i+1], b = data[i+2];
          if (mode === 'ordered'){
            const t = bayer4[((y&3)<<2) | (x&3)]/16 - 0.5; const off = t * 2 * (Number(strength)||0); r = clamp8(r+off); g = clamp8(g+off); b = clamp8(b+off);
          }
          out[k] = nq.map(b,g,r); // NeuQuant expects B,G,R
        }
      }
      return out;
    }
  }

  async function buildGlobalPalette(start, end, width, height, targetFPS){
    const MAX_SAMPLES = Number(devSampleCap?.value || 20000000);
    const STEP = Math.max(1, Number(devPixStep?.value || 4));
    const samples = [];

    await seekTo(video, start);
    video.muted = true; try{ await video.play(); }catch{}

    setStatus('Building global palette…', 0.02);

    const useRVFC = ('requestVideoFrameCallback' in HTMLVideoElement.prototype);
    await new Promise((resolve)=>{
      function take(){
        ctx.drawImage(video,0,0,width,height);
        const data = ctx.getImageData(0,0,width,height).data;
        for (let y=0; y<height && samples.length < MAX_SAMPLES*3; y+=STEP){
          let row = y*width*4;
          for (let x=0; x<width && samples.length < MAX_SAMPLES*3; x+=STEP){
            const i = row + x*4; // BGR order for NeuQuant
            samples.push(data[i+2], data[i+1], data[i]);
          }
        }
      }
      if (useRVFC){
        const step = (now, meta)=>{
          const t = meta.mediaTime || video.currentTime || 0; if (t <= end + 1e-6) take();
          if (samples.length >= MAX_SAMPLES*3 || t >= end - 0.002 || video.ended){ resolve(); return; }
          video.requestVideoFrameCallback(step);
        };
        video.requestVideoFrameCallback(step);
      } else {
        const iv = setInterval(()=>{
          const t = video.currentTime || 0; if (t <= end + 1e-6) take();
          if (samples.length >= MAX_SAMPLES*3 || t >= end - 0.002 || video.ended){ clearInterval(iv); resolve(); }
        }, Math.max(15, (1000/targetFPS)|0));
      }
    });
    try{ video.pause(); }catch{}

    const arr = new Uint8Array(samples);
    const nq = new NeuQuant(arr, nqSample);
    const colorTab = nq.process();
    return { nq, colorTab };
  }

  function buildLocalPaletteFromImage(img, width, height){
    const MAX_SAMPLES = Number(devSampleCap?.value || 20000000);
    const STEP = Math.max(1, Number(devPixStep?.value || 4));
    const limit = Math.min(MAX_SAMPLES, width*height);
    const data = img.data;
    const arr = new Uint8Array(Math.min(limit*3, width*height*3));
    let s = 0;
    for (let y=0; y<height && s < arr.length; y+=STEP){
      let row = y*width*4;
      for (let x=0; x<width && s < arr.length; x+=STEP){
        const i = row + x*4; // BGR order for NeuQuant
        arr[s++] = data[i+2]; arr[s++] = data[i+1]; arr[s++] = data[i];
      }
    }
    const samples = arr.subarray(0, s);
    const nq = new NeuQuant(samples, nqSample);
    const colorTab = nq.process();
    return { nq, colorTab };
  }

  // ---------- gif.js conversion pipeline ----------
  async function convertGifWithGifJS({width, height, targetFPS, startTime, endTime, fileDur, scale, sourceX, sourceY, sourceWidth, sourceHeight}){
    if (!sourceFile) throw new Error('No source file');

    const start = Math.max(0, Math.min(fileDur || 0, parseFloat(startTime)||0));
    const endBase = Math.max(start, Math.min(fileDur || 0, parseFloat(endTime)||fileDur));
    const minSpan = 1/targetFPS; const end = (endBase - start) < minSpan ? Math.min(fileDur, start + minSpan) : endBase;
    const span = Math.max(minSpan, (end - start) || minSpan);

    // Create GIF instance with gif.js
    const gif = new GIF({
      workers: 2,
      quality: nqSample, // Use the same quality setting as other encoders
      width: width,
      height: height,
      workerScript: window._gifWorkerURL,
      dither: chosenDither === 'none' ? false : chosenDither,
      repeat: 0 // Loop forever
    });

    let frameCount = 0;
    
    // Set up progress handling
    gif.on('start', () => {
      setStatus('gif.js initializing...', 0.05);
    });
    
    gif.on('progress', (p) => {
      setStatus(`gif.js encoding frames... ${Math.round(p * 100)}%`, 0.1 + p * 0.8);
    });

    gif.on('finished', (blob) => {
      const url = setOutput(blob, 'gif', 'image/gif');
      setStatus(`Done • ${(blob.size/1024/1024).toFixed(1)} MB`, 1);
      
      // Update output metadata
      const outputDuration = end - start;
      updateOutputMetadata(blob, 'GIF', 'gif.js', width, height, targetFPS, outputDuration);
      
      const img = new Image(); 
      img.src = url; 
      img.alt = 'Generated GIF (gif.js)';
      preview.innerHTML = '';
      preview.style.display = 'flex';
      preview.style.alignItems = 'center';
      preview.style.justifyContent = 'center';
      preview.appendChild(img);
      
      enableConvert(true);
    });

    gif.on('abort', () => {
      setStatus('err', 'gif.js encoding was aborted', 1);
      enableConvert(true);
    });

    try { video.pause(); } catch {}
    await seekTo(video, start);
    video.muted = true;
    try { await video.play(); } catch(e) {}

    setStatus('Extracting frames for gif.js...', 0.06);

    const useRVFC = ('requestVideoFrameCallback' in HTMLVideoElement.prototype);
    const dt = 1 / targetFPS;
    let lastDelayT = null; // timestamp of last added frame for computing per-frame delay

    if (useRVFC){
      await new Promise((resolve)=>{
        let lastCapture = start - 10;
        const step = (now, meta)=>{
          const t = meta.mediaTime || video.currentTime || 0;
          if (t + 1e-6 >= start && ((t - lastCapture) >= dt - 1e-6)){
            ctx.clearRect(0,0,width,height);
            ctx.drawImage(video, sourceX, sourceY, sourceWidth, sourceHeight, 0, 0, width, height);
            
            // Add frame to gif.js
            let delayMs;
            if (lastDelayT == null){
              delayMs = Math.round(1000 / targetFPS);
            } else {
              delayMs = Math.max(10, Math.round(((t - lastDelayT) * 1000) / 10) * 10);
            }
            gif.addFrame(canvas, {copy: true, delay: delayMs});
            frameCount++;
            
            lastCapture = t;
            lastDelayT = t;
          }
          const rel = Math.max(0, Math.min(span, (t - start)));
          const p = span ? Math.min(0.95, (rel/span)*0.95) : 0.5;
          setStatus(`Extracting frame ${frameCount} (t=${Math.max(start, Math.min(t,end)).toFixed(2)}s)...`, 0.06 + p * 0.04);
          if (t >= end - 0.002 || video.ended){ resolve(); return; }
          video.requestVideoFrameCallback(step);
        };
        video.requestVideoFrameCallback(step);
      });
    } else {
      await new Promise((resolve)=>{
        let lastEmit = start - 10;
        const iv = setInterval(()=>{
          const t = video.currentTime || 0;
          if (t + 1e-6 >= start && (t - lastEmit) >= dt - 1e-6){
            ctx.clearRect(0,0,width,height);
            ctx.drawImage(video, sourceX, sourceY, sourceWidth, sourceHeight, 0, 0, width, height);
            
            // Add frame to gif.js
            let delayMs;
            if (lastDelayT == null){
              delayMs = Math.round(1000 / targetFPS);
            } else {
              delayMs = Math.max(10, Math.round(((t - lastDelayT) * 1000) / 10) * 10);
            }
            gif.addFrame(canvas, {copy: true, delay: delayMs});
            frameCount++;
            
            lastEmit = t;
            lastDelayT = t;
          }
          const rel = Math.max(0, Math.min(span, (t - start)));
          const p = span ? Math.min(0.95, (rel/span)*0.95) : 0.5;
          setStatus(`Extracting frame ${frameCount} (t=${Math.max(start, Math.min(t,end)).toFixed(2)}s)...`, 0.06 + p * 0.04);
          if (t >= end - 0.002 || video.ended){ clearInterval(iv); resolve(); }
        }, Math.max(15, (1000/targetFPS)|0));
      });
    }

    try{ video.pause(); }catch{}
    
    setStatus('Starting gif.js rendering...', 0.1);
    gif.render();
  }

  // ---------- Conversion pipeline ----------
  goBtn.addEventListener('click', async ()=>{
    if (!video.src) return;
    enableConvert(false);

    const targetFPS = Number(chosenFps);
    const scale = Number(chosenScale);

    // Calculate dimensions based on crop settings
    let sourceX, sourceY, sourceWidth, sourceHeight;
    let width, height;
    
    if (cropEnabled && cropRegion) {
      sourceX = Math.round(cropRegion.x * video.videoWidth);
      sourceY = Math.round(cropRegion.y * video.videoHeight);
      sourceWidth = Math.round(cropRegion.width * video.videoWidth);
      sourceHeight = Math.round(cropRegion.height * video.videoHeight);
      width = Math.max(1, Math.round(sourceWidth * scale));
      height = Math.max(1, Math.round(sourceHeight * scale));
    } else {
      sourceX = 0;
      sourceY = 0;
      sourceWidth = video.videoWidth;
      sourceHeight = video.videoHeight;
      width = Math.max(1, Math.round(video.videoWidth * scale));
      height = Math.max(1, Math.round(video.videoHeight * scale));
    }
    
    canvas.width = width; canvas.height = height;
    ctx.imageSmoothingEnabled = false;

    const tmpCanvas = document.createElement('canvas');
    tmpCanvas.width = width; tmpCanvas.height = height;
    const tmpCtx = tmpCanvas.getContext('2d', { willReadFrequently: true });

    const dt = 1 / targetFPS;
    const fileDur = duration && isFinite(duration) ? duration : (isFinite(video.duration)?video.duration:0);
    let start = Math.max(0, Math.min(fileDur || 0, parseFloat(startTimeInput?.value)||0));
    let end = Math.max(start, Math.min(fileDur || 0, parseFloat(endTimeInput?.value)||fileDur));
    const minSpan = 1/targetFPS; if ((end - start) < minSpan) end = Math.min(fileDur, start + minSpan);
    const span = Math.max(minSpan, (end - start) || minSpan);

    const useGlobal = devGlobal ? devGlobal.checked : true;
    const dither = chosenDither !== 'none';
    const ditherMode = chosenDither === 'FloydSteinberg' ? 'floyd' : 'none';
    const ditherStrength = Number(devDitherS?.value || 18);

    // Route to appropriate encoder based on selection
    if (chosenEncoder === 'gifjs'){
      try{
        await convertGifWithGifJS({width, height, targetFPS, startTime: startTimeInput?.value, endTime: endTimeInput?.value, fileDur, scale, sourceX, sourceY, sourceWidth, sourceHeight});
        enableConvert(true);
        return;
      }catch(e){
        console.error(e);
        setStatus('err', 'gif.js encoder failed: ' + (e && e.message ? e.message : e), 1);
        enableConvert(true);
        return;
      }
    }

    

    const enc = new GIFEncoder(width, height);

    let nq = null, colorTab = null;
    if (useGlobal){
      ({nq, colorTab} = await buildGlobalPalette(start, end, width, height, targetFPS));
      enc.setGlobalPalette(colorTab);
    }

    enc.setRepeat(0);
    enc.setDelay(Math.round(1000 / targetFPS)); // default; per-frame override below
    enc.setQuality(nqSample);
    enc.start();

    setStatus('Starting playback…', 0.03);

    try { video.pause(); } catch {}
    await seekTo(video, start);

    video.muted = true;
    try { await video.play(); } catch(e) {}

    setStatus('Extracting & encoding frames…', 0.06);

    const useRVFC = ('requestVideoFrameCallback' in HTMLVideoElement.prototype);

    let pendingTime = null;
    let pendingIndexed = null; // Uint8Array
    let pendingImage = null;   // ImageData fallback
    let pendingPalette = null; // Uint8Array for local palette
    let emittedCs = 0;
    let accumSec = 0;

    function emitPending(nextTime){
      if (pendingTime === null) return;
      const delta = Math.max(0, nextTime - pendingTime);
      accumSec += delta;
      const totalCs = Math.max(1, Math.round(accumSec * 100));
      const csThis = Math.max(1, totalCs - emittedCs);
      enc.setDelay(csThis * 10);
      if (useGlobal){
        enc.addIndexedFrame(pendingIndexed);
      } else {
        if (pendingIndexed && pendingPalette){
          enc.setFramePalette(pendingPalette);
          enc.addIndexedFrame(pendingIndexed);
        } else if (pendingImage){
          tmpCtx.putImageData(pendingImage, 0, 0);
          enc.addFrame(tmpCtx);
        }
      }
      emittedCs += csThis;
      pendingIndexed = null; pendingImage = null; pendingPalette = null;
    }

    if (useRVFC){
      await new Promise((resolve)=>{
        let lastCapture = start - 10;
        const step = (now, meta)=>{
          const t = meta.mediaTime || video.currentTime || 0;
          if (t + 1e-6 >= start && ((t - lastCapture) >= dt - 1e-6 || pendingTime === null)){
            ctx.clearRect(0,0,width,height);
            ctx.drawImage(video, sourceX, sourceY, sourceWidth, sourceHeight, 0, 0, width, height);
            const img = ctx.getImageData(0,0,width,height);
            if (useGlobal){
              const idx = mapImageToIndexed(img, width, height, nq, colorTab, ditherMode, ditherStrength);
              if (pendingTime === null){ pendingTime = t; pendingIndexed = idx; }
              else { emitPending(t); pendingTime = t; pendingIndexed = idx; }
            } else {
              const lp = buildLocalPaletteFromImage(img, width, height);
              const idx = mapImageToIndexed(img, width, height, lp.nq, lp.colorTab, ditherMode, ditherStrength);
              if (pendingTime === null){ pendingTime = t; pendingIndexed = idx; pendingPalette = lp.colorTab; }
              else { emitPending(t); pendingTime = t; pendingIndexed = idx; pendingPalette = lp.colorTab; }
            }
            lastCapture = t;
          }
          const rel = Math.max(0, Math.min(span, (t - start)));
          const p = span ? Math.min(0.95, (rel/span)*0.95) : 0.5;
          setStatus(`Encoding frame ${Math.max(0, Math.floor(emittedCs/Math.max(1, Math.round(100/targetFPS)))) + (pendingTime!==null?1:0)} (t=${Math.max(start, Math.min(t,end)).toFixed(2)}s)…`, 0.06 + p);
          if (t >= end - 0.002 || video.ended){ resolve(); return; }
          video.requestVideoFrameCallback(step);
        };
        video.requestVideoFrameCallback(step);
      });
      try { video.pause(); } catch {}
    } else {
      await new Promise((resolve)=>{
        let lastEmit = start - 10;
        const iv = setInterval(()=>{
          const t = video.currentTime || 0;
          if (t + 1e-6 >= start && (t - lastEmit) >= dt - 1e-6){
            ctx.clearRect(0,0,width,height);
            ctx.drawImage(video, sourceX, sourceY, sourceWidth, sourceHeight, 0, 0, width, height);
            const img = ctx.getImageData(0,0,width,height);
            if (useGlobal){
              const idx = mapImageToIndexed(img, width, height, nq, colorTab, ditherMode, ditherStrength);
              if (pendingTime === null){ pendingTime = t; pendingIndexed = idx; }
              else { emitPending(t); pendingTime = t; pendingIndexed = idx; }
            } else {
              const lp = buildLocalPaletteFromImage(img, width, height);
              const idx = mapImageToIndexed(img, width, height, lp.nq, lp.colorTab, ditherMode, ditherStrength);
              if (pendingTime === null){ pendingTime = t; pendingIndexed = idx; pendingPalette = lp.colorTab; }
              else { emitPending(t); pendingTime = t; pendingIndexed = idx; pendingPalette = lp.colorTab; }
            }
            lastEmit = t;
          }
          const rel = Math.max(0, Math.min(span, (t - start)));
          const p = span ? Math.min(0.95, (rel/span)*0.95) : 0.5;
          setStatus(`Encoding frame … (t=${Math.max(start, Math.min(t,end)).toFixed(2)}s)…`, 0.06 + p);
          if (t >= end - 0.002 || video.ended){ clearInterval(iv); resolve(); }
        }, Math.max(15, (1000/targetFPS)|0));
      });
    }

    emitPending(end);

    setStatus('Finalizing GIF…', 0.97);
    try { enc.finish(); } catch(e) {
      console.error(e);
      setStatus('err', 'Failed to finalize GIF: ' + (e && e.message ? e.message : e), 1);
      enableConvert(true);
      return;
    }

    const blob = enc.stream().getBlob();
    const url = setOutput(blob, 'gif', 'image/gif');

    setStatus(`Done • ${(blob.size/1024/1024).toFixed(1)} MB`, 1);
    
    // Update output metadata
    const outputDuration = end - start;
    updateOutputMetadata(blob, 'GIF', 'JavaScript', width, height, targetFPS, outputDuration);

    const img = new Image(); img.src = url; img.alt = 'Generated GIF';
    preview.innerHTML = '';
    preview.style.display = 'flex';
    preview.style.alignItems = 'center';
    preview.style.justifyContent = 'center';
    preview.appendChild(img);

    enableConvert(true);
  });

  

  

  // ---------- WebM export (high color) ----------
  webmBtn?.addEventListener('click', async ()=>{
    if (!video.src || !canExportWebM()) return;

    const targetFPS = Number(chosenFps);
    const scale = Number(chosenScale);

    // Apply crop selection if enabled; otherwise use full frame
    let sourceX, sourceY, sourceWidth, sourceHeight;
    let width, height;
    if (cropEnabled && cropRegion) {
      sourceX = Math.round(cropRegion.x * video.videoWidth);
      sourceY = Math.round(cropRegion.y * video.videoHeight);
      sourceWidth = Math.round(cropRegion.width * video.videoWidth);
      sourceHeight = Math.round(cropRegion.height * video.videoHeight);
      width = Math.max(1, Math.round(sourceWidth * scale));
      height = Math.max(1, Math.round(sourceHeight * scale));
    } else {
      sourceX = 0; sourceY = 0;
      sourceWidth = video.videoWidth; sourceHeight = video.videoHeight;
      width = Math.max(1, Math.round(video.videoWidth * scale));
      height = Math.max(1, Math.round(video.videoHeight * scale));
    }

    canvas.width = width; canvas.height = height; ctx.imageSmoothingEnabled = false;

    const fileDur = duration && isFinite(duration) ? duration : (isFinite(video.duration)?video.duration:0);
    let start = Math.max(0, Math.min(fileDur || 0, parseFloat(startTimeInput?.value)||0));
    let end = Math.max(start, Math.min(fileDur || 0, parseFloat(endTimeInput?.value)||fileDur));
    const dt = 1/targetFPS; const span = Math.max(dt, (end - start) || dt);

    const stream = canvas.captureStream(targetFPS);
    const mime = (MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported('video/webm;codecs=vp9')) ? 'video/webm;codecs=vp9' : ((MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported('video/webm;codecs=vp8')) ? 'video/webm;codecs=vp8' : 'video/webm');
    const rec = new MediaRecorder(stream, {mimeType: mime, videoBitsPerSecond: 3000000});
    const chunks = [];
    rec.ondataavailable = e=> { if (e.data && e.data.size) chunks.push(e.data); };
    rec.onstop = async ()=>{
      const blob = new Blob(chunks, {type: mime});
      const url = setOutput(blob, 'webm', mime);
      setStatus(`WebM ready • ${(blob.size/1024/1024).toFixed(1)} MB`, 1);
      
      // Update output metadata
      const outputDuration = end - start;
      updateOutputMetadata(blob, 'WebM', 'MediaRecorder', width, height, targetFPS, outputDuration);
      
      const v = document.createElement('video'); v.src = url; v.controls = true; v.loop = true; v.muted = true; v.style.maxWidth='100%'; v.style.maxHeight='460px';
      preview.innerHTML = '';
      preview.style.display = 'flex';
      preview.style.alignItems = 'center';
      preview.style.justifyContent = 'center';
      preview.appendChild(v); try{ await v.play(); }catch{}
      webmBtn.disabled = false;
    };

    rec.start();

    try { video.pause(); } catch {}
    await seekTo(video, start);
    video.muted = true; try{ await video.play(); }catch{}

    setStatus('Recording WebM…', 0.06);

    const useRVFC = ('requestVideoFrameCallback' in HTMLVideoElement.prototype);
    if (useRVFC){
      await new Promise((resolve)=>{
        let lastCapture = start - 10;
        const step = (now, meta)=>{
          const t = meta.mediaTime || video.currentTime || 0;
          if (t + 1e-6 >= start && ((t - lastCapture) >= dt - 1e-6)){
            ctx.clearRect(0,0,width,height);
            ctx.drawImage(video, sourceX, sourceY, sourceWidth, sourceHeight, 0, 0, width, height);
            lastCapture = t;
          }
          const rel = Math.max(0, Math.min(span, (t - start)));
          const p = span ? Math.min(0.95, (rel/span)*0.95) : 0.5;
          setStatus(`Recording WebM (t=${Math.max(start, Math.min(t,end)).toFixed(2)}s)…`, 0.06 + p);
          if (t >= end - 0.002 || video.ended){ resolve(); return; }
          video.requestVideoFrameCallback(step);
        };
        video.requestVideoFrameCallback(step);
      });
    } else {
      await new Promise((resolve)=>{
        let lastEmit = start - 10; const iv = setInterval(()=>{
          const t = video.currentTime || 0;
          if (t + 1e-6 >= start && (t - lastEmit) >= dt - 1e-6){
            ctx.clearRect(0,0,width,height);
            ctx.drawImage(video, sourceX, sourceY, sourceWidth, sourceHeight, 0, 0, width, height);
            lastEmit = t;
          }
          const rel = Math.max(0, Math.min(span, (t - start)));
          const p = span ? Math.min(0.95, (rel/span)*0.95) : 0.5;
          setStatus(`Recording WebM (t=${Math.max(start, Math.min(t,end)).toFixed(2)}s)…`, 0.06 + p);
          if (t >= end - 0.002 || video.ended){ clearInterval(iv); resolve(); }
        }, Math.max(5, (1000/targetFPS)|0));
      });
    }

    try{ video.pause(); }catch{}
    rec.stop();
  });

  // ---------- WebP export (animated via ffmpeg.wasm) ----------
  let _ffmpeg = null;
  let _ffmpegFetchFile = null;
  async function ensureFFmpeg(){
    if (!_ffmpeg){
      const api = window.FFmpeg || window.ffmpeg || {};
      const createFFmpeg = api.createFFmpeg || (api.FFmpeg && api.FFmpeg.createFFmpeg);
      const fetchFile = api.fetchFile || (api.FFmpeg && api.FFmpeg.fetchFile);
      _ffmpeg = createFFmpeg ? createFFmpeg({ log: false, corePath: 'js/ffmpeg-core.js' }) : null;
      _ffmpegFetchFile = fetchFile || null;
    }
    if (!_ffmpeg) throw new Error('ffmpeg.wasm not available');
    if (!_ffmpeg.isLoaded()){
      setStatus('Loading encoder…', 0.02);
      await _ffmpeg.load();
    }
  }

  webpBtn?.addEventListener('click', async ()=>{
    if (!video.src) return;
    enableConvert(false);
    webpBtn.disabled = true;

    try{
      await ensureFFmpeg();
    }catch(e){
      setStatus('err', 'Failed to load encoder', 1);
      webpBtn.disabled = false; enableConvert(true); return;
    }

    const targetFPS = Number(chosenFps);
    const scale = Number(chosenScale);

    // Compute crop/output dimensions
    let sourceX, sourceY, sourceWidth, sourceHeight;
    let width, height;
    if (cropEnabled && cropRegion) {
      sourceX = Math.round(cropRegion.x * video.videoWidth);
      sourceY = Math.round(cropRegion.y * video.videoHeight);
      sourceWidth = Math.round(cropRegion.width * video.videoWidth);
      sourceHeight = Math.round(cropRegion.height * video.videoHeight);
      width = Math.max(1, Math.round(sourceWidth * scale));
      height = Math.max(1, Math.round(sourceHeight * scale));
    } else {
      sourceX = 0; sourceY = 0; sourceWidth = video.videoWidth; sourceHeight = video.videoHeight;
      width = Math.max(1, Math.round(video.videoWidth * scale));
      height = Math.max(1, Math.round(video.videoHeight * scale));
    }

    const fileDur = duration && isFinite(duration) ? duration : (isFinite(video.duration)?video.duration:0);
    let start = Math.max(0, Math.min(fileDur || 0, parseFloat(startTimeInput?.value)||0));
    let end = Math.max(start, Math.min(fileDur || 0, parseFloat(endTimeInput?.value)||fileDur));
    const minSpan = 1/Math.max(1, targetFPS);
    if ((end - start) < minSpan) end = Math.min(fileDur, start + minSpan);
    const span = Math.max(minSpan, (end - start) || minSpan);

    // Build filter graph
    const vf = [];
    if (cropEnabled && cropRegion){
      vf.push(`crop=${sourceWidth}:${sourceHeight}:${sourceX}:${sourceY}`);
    }
    vf.push(`fps=${targetFPS}`);
    vf.push(`scale=${width}:${height}:flags=neighbor`);
    const vfArg = vf.join(',');

    // Prepare input
    const inExt = (sourceFile && sourceFile.name && sourceFile.name.split('.').pop()) || 'mp4';
    const inName = `input.${inExt}`;
    const outName = 'out.webp';

    try{
      setStatus('Preparing encoder…', 0.04);
      try { _ffmpeg.FS('unlink', inName); }catch{}
      try { _ffmpeg.FS('unlink', outName); }catch{}
      const data = _ffmpegFetchFile ? await _ffmpegFetchFile(sourceFile) : new Uint8Array(await sourceFile.arrayBuffer());
      _ffmpeg.FS('writeFile', inName, data);

      // Progress callback
      if (_ffmpeg.setProgress){
        _ffmpeg.setProgress(({ ratio }) => {
          const p = Math.max(0, Math.min(1, ratio||0));
          setStatus(`Encoding WebP… ${Math.round(p*100)}%`, 0.1 + p*0.85);
        });
      }

      const args = [
        '-hide_banner',
        '-i', inName,
        '-ss', start.toFixed(3),
        '-t', span.toFixed(3),
        '-vf', vfArg,
        '-an',
        '-c:v', 'libwebp',
        '-q:v', String(webpQuality || 75),
        '-loop', '0',
        '-vsync', '0',
        outName
      ];

      setStatus('Starting WebP encode…', 0.08);
      await _ffmpeg.run(...args);

      const out = _ffmpeg.FS('readFile', outName);
      const blob = new Blob([out.buffer], {type: 'image/webp'});
      const url = setOutput(blob, 'webp', 'image/webp');
      setStatus(`WebP ready • ${(blob.size/1024/1024).toFixed(1)} MB`, 1);

      // Update output metadata
      updateOutputMetadata(blob, 'WebP', 'ffmpeg.wasm', width, height, targetFPS, span);

      const img = new Image(); img.src = url; img.alt = 'Generated WebP';
      preview.innerHTML = '';
      preview.style.display = 'flex';
      preview.style.alignItems = 'center';
      preview.style.justifyContent = 'center';
      preview.appendChild(img);
    }catch(err){
      console.error(err);
      setStatus('err', 'WebP export failed', 1);
    }finally{
      try { _ffmpeg.FS('unlink', inName); }catch{}
      try { _ffmpeg.FS('unlink', outName); }catch{}
      webpBtn.disabled = false;
      enableConvert(true);
    }
  });

  

  // ---------- GIF core (ByteArray + NeuQuant + Encoder) ----------

  function ByteArray(){
    this._chunks = [];
    this._buf = new Uint8Array(8192);
    this._pos = 0;
  }
  ByteArray.prototype._pushBuf = function(){
    if (this._pos > 0){ this._chunks.push(this._buf.subarray(0, this._pos)); this._buf = new Uint8Array(Math.max(8192, this._pos*2)); this._pos = 0; }
  };
  ByteArray.prototype.writeByte = function(b){
    if (this._pos >= this._buf.length) this._pushBuf();
    this._buf[this._pos++] = b & 0xFF;
  };
  ByteArray.prototype.writeUTFBytes = function(s){
    for (var i=0; i<s.length; i++){
      if (this._pos >= this._buf.length) this._pushBuf();
      this._buf[this._pos++] = s.charCodeAt(i) & 0xFF;
    }
  };
  ByteArray.prototype.writeShort = function(i){ this.writeByte(i & 0xFF); this.writeByte((i >> 8) & 0xFF); };
  ByteArray.prototype.getBlob = function(){ this._pushBuf(); return new Blob(this._chunks, {type:'image/gif'}); };

  function NeuQuant(pixels, samplefac){
    var netsize = 256; var maxnetpos = netsize-1; var netbiasshift = 4; var ncycles = 100;
    var intbiasshift = 16; var intbias = (1<<intbiasshift);
    var gammashift = 10; var gamma = (1<<gammashift); var betashift = 10; var beta = (intbias>>betashift); var betagamma = (intbias << (gammashift-betashift));
    var radiusbiasshift = 6; var radiusbias = (1<<radiusbiasshift); var initradius = (netsize>>3) * radiusbias; var radiusdec = 30;
    var alphabiasshift = 10; var initalpha = (1<<alphabiasshift); var alphadec = 30 + ((samplefac-1)/3)|0;
    var radbiasshift = 8; var radbias = (1<<radbiasshift); var alpharadbshift = alphabiasshift + radbiasshift; var alpharadbias = (1<<alpharadbshift);

    var thepicture = pixels; var lengthcount = thepicture.length; var samplepixels = (lengthcount/3)|0; var delta = (samplepixels/ncycles)|0; var alpha = initalpha; var radius = initradius;

    var net = new Array(netsize); for (var i=0; i<netsize; i++){ var v = ((i<< (netbiasshift+8))/netsize)|0; net[i] = [v,v,v,0,i]; }
    var freq = new Int32Array(netsize); var bias = new Int32Array(netsize); for (var i=0;i<netsize;i++){ freq[i]=intbias/netsize; bias[i]=0; }

    function contest(b,g,r){ var bestd = ~(1<<31); var bestbiasd = bestd; var bestpos = -1; var bestbiaspos = bestpos;
      for (var i=0;i<netsize;i++){
        var n = net[i]; var dist = Math.abs(n[0]-b) + Math.abs(n[1]-g) + Math.abs(n[2]-r);
        if (dist<bestd){ bestd=dist; bestpos=i; }
        var biasdist = dist - ((bias[i])>> (intbiasshift-netbiasshift)); if (biasdist<bestbiasd){ bestbiasd=biasdist; bestbiaspos=i; }
        var betafreq = freq[i]>> betashift; freq[i]-=betafreq; bias[i]+= (betafreq<< (gammashift));
      }
      freq[bestpos] += beta; bias[bestpos] -= betagamma; return bestbiaspos;
    }

    function altersingle(alpha,i,b,g,r){ var n=net[i]; n[0]-=(alpha*(n[0]-b))>>alphabiasshift; n[1]-=(alpha*(n[1]-g))>>alphabiasshift; n[2]-=(alpha*(n[2]-r))>>alphabiasshift; }
    function alterneigh(radius,i,b,g,r){ var lo = Math.max(i - radius, 0); var hi = Math.min(i + radius, maxnetpos);
      var j = i+1; var k = i-1; var q = 0; while ((j<=hi) || (k>=lo)){
        var a = (alpha * (radbias*(radius*radius - q*q) >> (8))) >> alphabiasshift;
        if (j<=hi){ var p = net[j++]; p[0]-=(a*(p[0]-b))>>alphabiasshift; p[1]-=(a*(p[1]-g))>>alphabiasshift; p[2]-=(a*(p[2]-r))>>alphabiasshift; }
        if (k>=lo){ var p2 = net[k--]; p2[0]-=(a*(p2[0]-b))>>alphabiasshift; p2[1]-=(a*(p2[1]-g))>>alphabiasshift; p2[2]-=(a*(p2[2]-r))>>alphabiasshift; }
        q++;
      }
    }

    function learn(){ var step = 0; var rad = radius >> radiusbiasshift; if (rad<=1) rad=0;
      var pos = 0; var lim = lengthcount; var i=0;
      while (i < lim){ var b = thepicture[pos] & 0xff; var g = thepicture[pos+1] & 0xff; var r = thepicture[pos+2] & 0xff; var j = contest(b,g,r);
        altersingle(alpha, j, b,g,r); if (rad) alterneigh(rad, j, b,g,r);
        pos += samplefac*3; if (pos >= lengthcount) pos -= lengthcount;
        i += samplefac;
        if (delta && i % delta === 0){ alpha -= alpha/alphadec; radius -= radius/radiusdec; rad = radius>>radiusbiasshift; if (rad<=1) rad=0; }
      }
    }

    function buildColormap(){ learn(); net.sort(function(a,b){ return a[4]-b[4]; });
      var colorTab = new Uint8Array(3*netsize); var k=0; for (var i=0;i<netsize;i++){ var n=net[i]; colorTab[k++] = n[0]; colorTab[k++] = n[1]; colorTab[k++] = n[2]; }
      return colorTab;
    }

    this.process = function(){ return buildColormap(); };
    this.map = function(b,g,r){ var bestd = 1<<30; var best = -1; for (var i=0;i<netsize;i++){ var n = net[i]; var d = Math.abs(n[0]-b)+Math.abs(n[1]-g)+Math.abs(n[2]-r); if (d<bestd){ bestd=d; best=i; } } return best; };
  }

  function LZWEncoder(width, height, pixels, colorDepth){
    var imgW = width, imgH = height, pixAry = pixels, initCodeSize = Math.max(2, colorDepth|0);
    var remaining = imgW * imgH, curPixel = 0;

    var BITS = 12, HSIZE = 5003;
    var n_bits, maxbits = BITS, maxcode, maxmaxcode = 1 << BITS;
    var htab = new Int32Array(HSIZE), codetab = new Int32Array(HSIZE), hsize = HSIZE;
    var free_ent = 0, clear_flg = false, g_init_bits, ClearCode, EOFCode;
    var cur_accum = 0, cur_bits = 0, a_count = 0, accum = new Uint8Array(256);
    var masks = [0,1,3,7,15,31,63,127,255,511,1023,2047,4095];

    function MAXCODE(n){ return (1<<n)-1; }
    function nextPixel(){ if (remaining === 0) return -1; remaining--; return pixAry[curPixel++] & 0xff; }
    function cl_hash(n){ for (var i=0;i<n;i++) htab[i] = -1; }
    function char_init(){ a_count = 0; }
    function char_out(c, outs){ accum[a_count++] = c & 0xFF; if (a_count >= 254) flush_char(outs); }
    function flush_char(outs){ if (a_count > 0){ outs.writeByte(a_count); for (var i=0;i<a_count;i++) outs.writeByte(accum[i]); a_count = 0; } }
    function output(code, outs){
      cur_accum &= masks[cur_bits];
      if (cur_bits > 0) cur_accum |= (code << cur_bits); else cur_accum = code;
      cur_bits += n_bits;
      while (cur_bits >= 8){ char_out(cur_accum & 0xFF, outs); cur_accum >>= 8; cur_bits -= 8; }
      if (free_ent > maxcode || clear_flg){
        if (clear_flg){ n_bits = g_init_bits; maxcode = MAXCODE(n_bits); clear_flg = false; }
        else { n_bits++; maxcode = (n_bits == maxbits) ? maxmaxcode : MAXCODE(n_bits); }
      }
      if (code == EOFCode){ while (cur_bits > 0){ char_out(cur_accum & 0xFF, outs); cur_accum >>= 8; cur_bits -= 8; } flush_char(outs); }
    }
    function cl_block(outs){ cl_hash(hsize); free_ent = ClearCode + 2; clear_flg = true; output(ClearCode, outs); }

    function compress(init_bits, outs){
      var fcode, c, i, ent, disp, hshift;
      g_init_bits = init_bits; clear_flg = false; n_bits = g_init_bits; maxcode = MAXCODE(n_bits);
      ClearCode = 1 << (init_bits - 1); EOFCode = ClearCode + 1; free_ent = ClearCode + 2;
      char_init(); ent = nextPixel();
      hshift = 0; for (fcode = hsize; fcode < 65536; fcode *= 2) ++hshift; hshift = 8 - hshift; disp = 1 << hshift;
      cl_hash(hsize); output(ClearCode, outs);
      outer: while ((c = nextPixel()) != -1){
        fcode = (c << maxbits) + ent; i = ((c << hshift) ^ ent);
        if (htab[i] === fcode){ ent = codetab[i]; continue; }
        else if (htab[i] >= 0){
          while (true){ i -= disp; if (i < 0) i += hsize; if (htab[i] === fcode){ ent = codetab[i]; continue outer; } if (htab[i] === -1) break; }
        }
        output(ent, outs); ent = c;
        if (free_ent < maxmaxcode){ codetab[i] = free_ent++; htab[i] = fcode; }
        else cl_block(outs);
      }
      output(ent, outs); output(EOFCode, outs);
    }

    this.encode = function(outs){ outs.writeByte(initCodeSize); compress(initCodeSize + 1, outs); };
  }

  function GIFEncoder(width, height){
    var transparent = null; var transIndex = 0; var repeat = 0; var delay = 0; var started = false; var out = new ByteArray();
    var image; var pixels; var indexedPixels; var colorDepth = 8; var colorTab; var palSize = 7; var sample = 10; var useGlobal = false;

    this.setDelay = function(ms){ delay = Math.max(0, ms|0); };
    this.setRepeat = function(repeatCount){ repeat = repeatCount; };
    this.setTransparent = function(color){ transparent = color; };
    this.setQuality = function(q){ sample = Math.max(1, q|0); };
    this.setGlobalPalette = function(tab){ colorTab = tab; colorDepth = 8; palSize = 7; useGlobal = true; };

    // For local-palette mode: set per-frame palette before addIndexedFrame
    this.setFramePalette = function(tab){ colorTab = tab; /* keep useGlobal=false so palette is written per frame */ };

    this.start = function(){ out = new ByteArray(); writeHeader(); writeLSD(width, height); if (repeat >= 0) writeNetscapeExt(repeat); started = true; };
    this.finish = function(){ writeTrailer(); started = false; };
    this.stream = function(){ return out; };

    this.addFrame = function(im){ // per-frame quantization (fallback)
      if (!started) throw new Error('Call start() before addFrame().');
      var w = width, h = height;
      image = im.getImageData(0,0,w,h);
      pixels = image.data; // RGBA
      // Train NeuQuant with B,G,R order (expected by implementation)
      var train = new Uint8Array(w*h*3);
      for (var i=0, j=0; i<pixels.length; i+=4){ train[j++] = pixels[i+2]; train[j++] = pixels[i+1]; train[j++] = pixels[i]; }
      var nq = new NeuQuant(train, sample);
      colorTab = nq.process();
      indexedPixels = new Uint8Array(w*h);
      var k=0; for (var y=0;y<h;y++){
        for (var x=0;x<w;x++){
          var off = (k<<2);
          var r = pixels[off], g = pixels[off+1], b = pixels[off+2];
          indexedPixels[k++] = nq.map(b,g,r); // pass B,G,R to mapper
        }
      }
      writeGraphicCtrlExt();
      writeImageDesc(w,h);
      if (!useGlobal) writePalette();
      writePixels(indexedPixels);
    };

    this.addIndexedFrame = function(indexed){
      if (!started) throw new Error('Call start() before addIndexedFrame().');
      writeGraphicCtrlExt();
      writeImageDesc(width,height);
      if (!useGlobal) writePalette();
      writePixels(indexed);
    };

    function writeHeader(){ out.writeUTFBytes('GIF89a'); }
    function writeLSD(w,h){ out.writeShort(w); out.writeShort(h); out.writeByte(useGlobal ? 0xF7 : 0x70); out.writeByte(0); out.writeByte(0); if (useGlobal) writePalette(); }
    function writePalette(){
      // Convert NeuQuant BGR → GIF RGB
      for (var i=0; i<colorTab.length; i+=3){ out.writeByte(colorTab[i+2]); out.writeByte(colorTab[i+1]); out.writeByte(colorTab[i]); }
      var n = (3 * 256) - colorTab.length; for (var j=0;j<n;j++) out.writeByte(0);
    }
    function writeGraphicCtrlExt(){ out.writeByte(0x21); out.writeByte(0xf9); out.writeByte(4); var transp = transparent !== null ? 1 : 0; var disp = transp ? 2 : 0; out.writeByte((disp<<2) | 0 | 0 | transp); out.writeShort(Math.max(1, Math.round(delay/10))); out.writeByte(transIndex); out.writeByte(0); }
    function writeImageDesc(w,h){ out.writeByte(0x2c); out.writeShort(0); out.writeShort(0); out.writeShort(w); out.writeShort(h); out.writeByte(useGlobal ? 0x00 : (0x80 | palSize)); }
    function writePixels(indexed){ var lzw = new LZWEncoder(width, height, indexed, colorDepth); lzw.encode(out); out.writeByte(0x00); }
    function writeTrailer(){ out.writeByte(0x3b); }

    function writeNetscapeExt(loopCount){ out.writeByte(0x21); out.writeByte(0xff); out.writeByte(11); out.writeUTFBytes('NETSCAPE2.0'); out.writeByte(3); out.writeByte(1); out.writeShort(loopCount); out.writeByte(0); }
  }

  // ---------- Timeline Controller ----------
  class TimelineController {
    constructor(videoPreview) {
      this.videoPreview = videoPreview;
      this.initializeElements();
      
      this.elements.timeline._timelineController = this;
      
      this.initializeEventListeners();
      this.isDragging = false;
      this.currentMarker = null;
      this.isPlaying = false;
      this.videoDuration = 0;
      this.isScrubbingPlayhead = false;
      this.wasPlaying = false;
      
      // Always keep video muted
      this.videoPreview.muted = true;
      
      this.initializeTimelineDrag();
      
      // Bind the handlers to preserve context
      this.handleTimelineDrag = this.handleTimelineDrag.bind(this);
      this.handleTimelineDragEnd = this.handleTimelineDragEnd.bind(this);
    }

    initializeElements() {
      this.elements = {
        timeline: document.querySelector('.timeline'),
        startMarker: document.querySelector('.start-marker'),
        endMarker: document.querySelector('.end-marker'),
        startTimeDisplay: document.querySelector('.start-time'),
        endTimeDisplay: document.querySelector('.end-time'),
        startTimeInput: document.getElementById('startTime'),
        endTimeInput: document.getElementById('endTime'),
        playPauseBtn: document.querySelector('.play-pause-btn'),
        playhead: document.querySelector('.playhead'),
        durationDisplay: document.querySelector('.duration-time')
      };
    }

    initializeEventListeners() {
      this.videoPreview.addEventListener('loadedmetadata', this.handleVideoLoad.bind(this));
      this.videoPreview.addEventListener('timeupdate', this.handleTimeUpdate.bind(this));
      this.elements.timeline.addEventListener('mousedown', this.handleTimelineClick.bind(this));
      
      [this.elements.startMarker, this.elements.endMarker].forEach(marker => {
        marker.addEventListener('mousedown', this.handleMarkerDragStart.bind(this));
      });

      document.addEventListener('mousemove', this.handleMarkerDrag.bind(this));
      document.addEventListener('mouseup', this.handleMarkerDragEnd.bind(this));
      
      this.elements.playPauseBtn.addEventListener('click', this.togglePlayPause.bind(this));
      this.videoPreview.addEventListener('pause', () => this.updatePlayButton(false));
      this.videoPreview.addEventListener('play', () => this.updatePlayButton(true));
      
      // Add debounced input handling for real-time preview while typing
      this.inputDebounceTimer = null;
      
      const debouncedInputHandler = (e) => {
        clearTimeout(this.inputDebounceTimer);
        this.inputDebounceTimer = setTimeout(() => this.handleTimeInputChange(e), 300);
      };
      
      this.elements.startTimeInput.addEventListener('input', debouncedInputHandler);
      this.elements.endTimeInput.addEventListener('input', debouncedInputHandler);
      
      // Also handle immediate change events (when user finishes editing)
      this.elements.startTimeInput.addEventListener('change', (e) => this.handleTimeInputChange(e));
      this.elements.endTimeInput.addEventListener('change', (e) => this.handleTimeInputChange(e));
      
      // Keyboard shortcuts
      document.addEventListener('keydown', this.handleKeyDown.bind(this));
    }

    handleVideoLoad() {
      if (!this.videoPreview.duration) return;
      
      this.videoDuration = this.videoPreview.duration;
      
      // Ensure video is always muted
      this.videoPreview.muted = true;
      
      // Update time displays
      this.elements.startTimeDisplay.textContent = this.formatTime(0);
      this.elements.endTimeDisplay.textContent = this.formatTime(this.videoDuration);
      
      // Update time inputs max values
      this.elements.startTimeInput.max = this.videoDuration.toFixed(2);
      this.elements.endTimeInput.max = this.videoDuration.toFixed(2);
      this.elements.endTimeInput.value = this.videoDuration.toFixed(2);
      
      // Enable buttons
      [this.elements.playPauseBtn].forEach(btn => {
        btn.disabled = false;
      });
      
      // Set initial button text
      this.updatePlayButton(false);
      
      this.updateMarkerPositions();
      this.updateDurationDisplay();
      this.setTimelineEnabled(true);
    }

    formatTime(seconds) {
      const minutes = Math.floor(seconds / 60);
      const secs = seconds % 60;
      return `${minutes}:${secs.toFixed(2).padStart(5, '0')}`;
    }

    updateMarkerPositions() {
      const duration = this.videoDuration || this.videoPreview.duration;
      if (!duration) return;

      const startTime = parseFloat(this.elements.startTimeInput.value) || 0;
      const endTime = parseFloat(this.elements.endTimeInput.value) || duration;

      const startPercent = (startTime / duration) * 100;
      const endPercent = (endTime / duration) * 100;

      this.elements.startMarker.style.left = `${startPercent}%`;
      this.elements.endMarker.style.left = `${endPercent}%`;
    }

    updateDurationDisplay() {
      const startTime = parseFloat(this.elements.startTimeInput.value) || 0;
      const endTime = parseFloat(this.elements.endTimeInput.value) || this.videoDuration;
      const actualDuration = endTime - startTime;

      if (this.elements.durationDisplay) {
        this.elements.durationDisplay.innerHTML = 
          `Duration: <span style="color: var(--text)">${actualDuration.toFixed(1)}s</span>`;
      }
    }

    handleTimelineClick(e) {
      if (!this.videoPreview.src) {
        return;
      }
      
      // If we're already dragging the playhead, don't handle the click
      if (this.isScrubbingPlayhead) {
        return;
      }
      
      const rect = this.elements.timeline.getBoundingClientRect();
      const position = (e.clientX - rect.left) / rect.width;
      const duration = this.videoDuration || this.videoPreview.duration;
      let time = position * duration;
      
      // Constrain seeking to within the trim range
      const startTime = parseFloat(this.elements.startTimeInput.value) || 0;
      const endTime = parseFloat(this.elements.endTimeInput.value) || duration;
      time = Math.max(startTime, Math.min(endTime, time));
      
      this.videoPreview.currentTime = time;
      this.updatePlayhead();
    }

    handleMarkerDragStart(e) {
      e.preventDefault();
      e.stopPropagation();
      
      this.isDragging = true;
      this.currentMarker = e.target;
      
      // Immediately show the frame at the current marker position
      if (this.currentMarker === this.elements.startMarker) {
        const startTime = parseFloat(this.elements.startTimeInput.value) || 0;
        this.videoPreview.currentTime = startTime;
      } else if (this.currentMarker === this.elements.endMarker) {
        const endTime = parseFloat(this.elements.endTimeInput.value) || this.videoDuration;
        this.videoPreview.currentTime = endTime;
      }
      
      document.body.style.userSelect = 'none';
    }

    handleMarkerDrag(e) {
      if (!this.isDragging || !this.currentMarker) return;
      
      e.preventDefault();
      
      const rect = this.elements.timeline.getBoundingClientRect();
      let position = (e.clientX - rect.left) / rect.width;
      position = Math.max(0, Math.min(1, position));
      
      const duration = this.videoDuration || this.videoPreview.duration;
      const time = position * duration;
      
      if (this.currentMarker === this.elements.startMarker) {
        const endTime = parseFloat(this.elements.endTimeInput.value);
        if (time < endTime) {
          this.elements.startTimeInput.value = time.toFixed(2);
          this.elements.startTimeDisplay.textContent = this.formatTime(time);
          // Update video preview to show the frame at the start handle position
          this.videoPreview.currentTime = time;
        }
      } else if (this.currentMarker === this.elements.endMarker) {
        const startTime = parseFloat(this.elements.startTimeInput.value);
        if (time > startTime) {
          this.elements.endTimeInput.value = time.toFixed(2);
          this.elements.endTimeDisplay.textContent = this.formatTime(time);
          // Update video preview to show the frame at the end handle position
          this.videoPreview.currentTime = time;
        }
      }
      
      this.updateMarkerPositions();
      this.updateDurationDisplay();
    }

    handleMarkerDragEnd() {
      if (!this.isDragging) return;
      
      this.isDragging = false;
      this.currentMarker = null;
      document.body.style.userSelect = '';
    }

    handleTimeUpdate() {
      this.updatePlayhead();
      
      // Continuous loop between trim handles when playing
      if (this.isPlaying) {
        const startTime = parseFloat(this.elements.startTimeInput.value) || 0;
        const endTime = parseFloat(this.elements.endTimeInput.value) || this.videoDuration;
        const currentTime = this.videoPreview.currentTime;
        
        // Safety check: ensure minimum duration between start and end
        const minDuration = 0.1; // Minimum 0.1 seconds
        if ((endTime - startTime) >= minDuration && currentTime >= endTime) {
          // Loop back to start instead of pausing
          this.videoPreview.currentTime = startTime;
        } else if ((endTime - startTime) < minDuration && currentTime >= (startTime + minDuration)) {
          // If range is too small, loop with minimum duration
          this.videoPreview.currentTime = startTime;
        }
      }
    }

    updatePlayhead() {
      if (!this.videoPreview.duration) return;
      
      const currentTime = this.videoPreview.currentTime;
      const duration = this.videoDuration || this.videoPreview.duration;
      let position = (currentTime / duration) * 100;
      
      // When playing in loop mode, constrain playhead to trim range visually
      if (this.isPlaying) {
        const startTime = parseFloat(this.elements.startTimeInput.value) || 0;
        const endTime = parseFloat(this.elements.endTimeInput.value) || duration;
        const startPercent = (startTime / duration) * 100;
        const endPercent = (endTime / duration) * 100;
        
        // Constrain position to trim range
        position = Math.max(startPercent, Math.min(endPercent, position));
      }
      
      this.elements.playhead.style.left = `${position}%`;
      this.elements.playhead.style.display = 'block';
    }

    handleTimeInputChange(e) {
      this.updateMarkerPositions();
      this.updateDurationDisplay();
      validateTimeInputs();
      
      // Show the frame at the changed time input
      if (e && e.target) {
        const newTime = parseFloat(e.target.value) || 0;
        if (newTime >= 0 && newTime <= this.videoDuration) {
          this.videoPreview.currentTime = newTime;
        }
      }
    }

    togglePlayPause() {
      if (!this.videoPreview.src) return;
      
      if (this.videoPreview.paused) {
        // Start playback from the start trim handle
        const startTime = parseFloat(this.elements.startTimeInput.value) || 0;
        this.videoPreview.currentTime = startTime;
        
        this.videoPreview.play().catch(() => {
          this.isPlaying = false;
          this.updatePlayButton(false);
        });
      } else {
        this.videoPreview.pause();
      }
    }

    updatePlayButton(isPlaying) {
      this.isPlaying = isPlaying;
      if (isPlaying) {
        this.elements.playPauseBtn.textContent = 'Pause';
        this.elements.playPauseBtn.style.backgroundColor = 'var(--accent)';
        this.elements.playPauseBtn.style.color = 'white';
      } else {
        this.elements.playPauseBtn.textContent = 'Play';
        this.elements.playPauseBtn.style.backgroundColor = '';
        this.elements.playPauseBtn.style.color = '';
      }
    }



    handleKeyDown(e) {
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
        return;
      }

      switch (e.code) {
        case 'Space':
          e.preventDefault();
          this.togglePlayPause();
          break;
        case 'BracketLeft':
          e.preventDefault();
          this.setMarkerAtPlayhead('start');
          break;
        case 'BracketRight':
          e.preventDefault();
          this.setMarkerAtPlayhead('end');
          break;
        case 'ArrowLeft':
          e.preventDefault();
          this.stepFrame(-1);
          break;
        case 'ArrowRight':
          e.preventDefault();
          this.stepFrame(1);
          break;
      }
    }

    setMarkerAtPlayhead(type) {
      const currentTime = this.videoPreview.currentTime;
      
      if (type === 'start') {
        this.elements.startTimeInput.value = currentTime.toFixed(2);
        this.elements.startTimeDisplay.textContent = this.formatTime(currentTime);
        // Ensure video shows this frame
        this.videoPreview.currentTime = currentTime;
      } else if (type === 'end') {
        this.elements.endTimeInput.value = currentTime.toFixed(2);
        this.elements.endTimeDisplay.textContent = this.formatTime(currentTime);
        // Ensure video shows this frame
        this.videoPreview.currentTime = currentTime;
      }
      
      this.updateMarkerPositions();
      this.updateDurationDisplay();
    }

    stepFrame(direction) {
      if (!this.videoPreview.src) return;
      
      const frameRate = 30; // Assume 30fps for frame stepping
      const frameTime = 1 / frameRate;
      const newTime = this.videoPreview.currentTime + (direction * frameTime);
      
      this.videoPreview.currentTime = Math.max(0, Math.min(this.videoDuration, newTime));
    }

    setTimelineEnabled(enabled) {
      const opacity = enabled ? '1' : '0.5';
      const cursor = enabled ? 'pointer' : 'not-allowed';
      
      this.elements.timeline.style.opacity = opacity;
      this.elements.timeline.style.cursor = cursor;
      this.elements.startMarker.style.opacity = opacity;
      this.elements.endMarker.style.opacity = opacity;
      this.elements.playPauseBtn.disabled = !enabled;
      this.elements.playhead.style.display = 'none';
      
      if (!enabled) {
        this.elements.playPauseBtn.textContent = 'Play';
        this.elements.playPauseBtn.style.backgroundColor = '';
        this.elements.playPauseBtn.style.color = '';
      }
    }

    initializeTimelineDrag() {
      this.elements.timeline.addEventListener('mousedown', (e) => {
        if (!this.videoPreview.src) return;
        
        this.isScrubbingPlayhead = true;
        this.wasPlaying = this.isPlaying;
        if (this.isPlaying) {
          this.videoPreview.pause();
        }
        
        // Handle the initial click position
        const rect = this.elements.timeline.getBoundingClientRect();
        let position = (e.clientX - rect.left) / rect.width;
        position = Math.max(0, Math.min(1, position));
        
        const duration = this.videoDuration || this.videoPreview.duration;
        let time = position * duration;
        
        // Constrain dragging to within the trim range
        const startTime = parseFloat(this.elements.startTimeInput.value) || 0;
        const endTime = parseFloat(this.elements.endTimeInput.value) || duration;
        time = Math.max(startTime, Math.min(endTime, time));
        
        if (duration > 0) {
          this.videoPreview.currentTime = time;
          this.elements.playhead.style.display = 'block';
          // Update position based on constrained time
          const constrainedPosition = time / duration;
          this.elements.playhead.style.left = `${constrainedPosition * 100}%`;
        }
        
        document.addEventListener('mousemove', this.handleTimelineDrag);
        document.addEventListener('mouseup', this.handleTimelineDragEnd);
      });

      // Define bound event handlers
      this.handleTimelineDrag = (e) => {
        if (!this.isScrubbingPlayhead) return;
        
        e.preventDefault();
        
        const rect = this.elements.timeline.getBoundingClientRect();
        let position = (e.clientX - rect.left) / rect.width;
        position = Math.max(0, Math.min(1, position));
        
        const duration = this.videoDuration || this.videoPreview.duration;
        let time = position * duration;
        
        // Constrain dragging to within the trim range
        const startTime = parseFloat(this.elements.startTimeInput.value) || 0;
        const endTime = parseFloat(this.elements.endTimeInput.value) || duration;
        time = Math.max(startTime, Math.min(endTime, time));
        
        if (duration > 0) {
          this.videoPreview.currentTime = time;
          // Update position based on constrained time
          const constrainedPosition = time / duration;
          this.elements.playhead.style.left = `${constrainedPosition * 100}%`;
        }
      };

      this.handleTimelineDragEnd = () => {
        if (!this.isScrubbingPlayhead) return;
        
        this.isScrubbingPlayhead = false;
        
        // Remove temporary event listeners
        document.removeEventListener('mousemove', this.handleTimelineDrag);
        document.removeEventListener('mouseup', this.handleTimelineDragEnd);
        
        if (this.wasPlaying) {
          this.videoPreview.play().catch(() => {
            this.isPlaying = false;
            this.updatePlayButton(false);
          });
        }
      };
    }
  }

  // Crop initialization and functionality
  function initializeCropping() {
    cropEnabled = false;
    cropRegion = null;
    
    cropOverlay = document.createElement('div');
    cropOverlay.className = 'crop-overlay';
    
    cropRegionElement = document.createElement('div');
    cropRegionElement.className = 'crop-region';
    
    ['nw', 'ne', 'sw', 'se'].forEach(pos => {
      const handle = document.createElement('div');
      handle.className = `crop-handle ${pos}`;
      cropRegionElement.appendChild(handle);
    });
    
    cropOverlay.appendChild(cropRegionElement);
    
    const toggleButton = document.getElementById('toggleCrop');
    if (toggleButton) {
      toggleButton.addEventListener('click', () => toggleCrop());
    }
    
    initializeCropDrag();
  }

  function toggleCrop() {
    const videoPreview = document.getElementById('srcPreview');
    if (!videoPreview || !videoPreview.src) {
      return;
    }

    const videoContainer = videoPreview.parentElement;
    const toggleButton = document.getElementById('toggleCrop');
    
    if (!cropEnabled) {
      videoContainer.appendChild(cropOverlay);
      cropOverlay.style.display = 'block';
      toggleButton.classList.add('active');
      toggleButton.querySelector('span').textContent = 'Disable Crop';
      
      // Only initialize crop region if it doesn't exist
      if (!cropRegion) {
        initializeCropRegion();
      } else {
        // Just update the existing crop region
        updateCropRegionElement();
      }
      
      if (!resizeObserver) {
        resizeObserver = new ResizeObserver(() => {
          if (cropEnabled) {
            updateCropRegionOnResize();
          }
        });
        resizeObserver.observe(videoContainer);
      }
      
      cropEnabled = true;
      updateCropDimensions();
    } else {
      cropOverlay.style.display = 'none';
      toggleButton.classList.remove('active');
      toggleButton.querySelector('span').textContent = 'Enable Crop';
      
      if (resizeObserver) {
        resizeObserver.disconnect();
        resizeObserver = null;
      }
      
      cropEnabled = false;
      updateOutputDimensions();
    }
  }

  function initializeCropRegion() {
    const video = document.getElementById('srcPreview');
    
    // Start with full video size
    cropRegion = {
      x: 0,
      y: 0,
      width: 1,
      height: 1
    };
    
    updateCropRegionElement();
    updateOutputDimensions();
  }

  function updateCropRegionElement() {
    const videoPreview = document.getElementById('srcPreview');
    
    // Determine displayed video content area within the element (accounts for letterbox/pillarbox)
    const displayArea = getVideoDisplayArea(videoPreview);
    const displayWidth = displayArea.width;
    const displayHeight = displayArea.height;
    const offsetX = displayArea.x;
    const offsetY = displayArea.y;

    // Position crop region within the actual video content area
    // Note: crop region is a child of the overlay, so its coordinates are
    // relative to the overlay's top-left. Do NOT add offsetX/offsetY here.
    Object.assign(cropRegionElement.style, {
      left: `${cropRegion.x * displayWidth}px`,
      top: `${cropRegion.y * displayHeight}px`,
      width: `${cropRegion.width * displayWidth}px`,
      height: `${cropRegion.height * displayHeight}px`
    });

    // Position the crop overlay to cover only the video content area
    Object.assign(cropOverlay.style, {
      left: `${offsetX}px`,
      top: `${offsetY}px`,
      width: `${displayWidth}px`,
      height: `${displayHeight}px`
    });
    
    updateCropDimensions();
  }

  function updateCropDimensions() {
    const dimensions = document.getElementById('cropDimensions');
    const sizeText = document.getElementById('cropSize');
    const videoPreview = document.getElementById('srcPreview');
    
    if (!dimensions || !sizeText || !videoPreview || !cropRegion) return;
    
    const videoWidth = videoPreview.videoWidth;
    const videoHeight = videoPreview.videoHeight;
    
    if (!videoWidth || !videoHeight) return;
    
    const pixelWidth = Math.round(cropRegion.width * videoWidth);
    const pixelHeight = Math.round(cropRegion.height * videoHeight);
    
    const finalWidth = Math.round(pixelWidth * chosenScale);
    const finalHeight = Math.round(pixelHeight * chosenScale);
    
    dimensions.style.display = 'block';
    sizeText.innerHTML = `
      Crop: <span style="color: var(--accent)">${pixelWidth} × ${pixelHeight}px</span>
      <br>
      Output: <span style="color: var(--ok)">${finalWidth} × ${finalHeight}px</span>
    `;
  }

  function updateOutputDimensions() {
    const dimensions = document.getElementById('cropDimensions');
    const sizeText = document.getElementById('cropSize');
    const videoPreview = document.getElementById('srcPreview');
    
    if (!dimensions || !sizeText || !videoPreview) return;
    
    const originalWidth = videoPreview.videoWidth;
    const originalHeight = videoPreview.videoHeight;
    
    if (!originalWidth || !originalHeight) return;
    
    const finalWidth = Math.round(originalWidth * chosenScale);
    const finalHeight = Math.round(originalHeight * chosenScale);
    
    dimensions.style.display = 'block';
    if (cropEnabled) {
      updateCropDimensions();
    } else {
      sizeText.innerHTML = `
        <span style="color: var(--ok)">${finalWidth} × ${finalHeight}px</span>
      `;
    }
  }

  function getVideoDisplayArea(videoElement) {
    const videoRect = videoElement.getBoundingClientRect();
    const videoWidth = videoElement.videoWidth;
    const videoHeight = videoElement.videoHeight;
    
    if (!videoWidth || !videoHeight) {
      // Video not loaded, return container dimensions
      return {
        x: 0,
        y: 0,
        width: videoRect.width,
        height: videoRect.height
      };
    }
    
    const containerAspectRatio = videoRect.width / videoRect.height;
    const videoAspectRatio = videoWidth / videoHeight;
    
    let displayWidth, displayHeight;
    let offsetX = 0, offsetY = 0;
    
    if (videoAspectRatio > containerAspectRatio) {
      // Video is wider than container - letterboxing (black bars top/bottom)
      displayWidth = videoRect.width;
      displayHeight = videoRect.width / videoAspectRatio;
      offsetY = (videoRect.height - displayHeight) / 2;
    } else {
      // Video is taller than container - pillarboxing (black bars left/right)
      displayHeight = videoRect.height;
      displayWidth = videoRect.height * videoAspectRatio;
      offsetX = (videoRect.width - displayWidth) / 2;
    }
    
    return {
      x: offsetX,
      y: offsetY,
      width: displayWidth,
      height: displayHeight
    };
  }



  function updateCropRegionOnResize() {
    // Just call updateCropRegionElement since it now handles all the positioning
    updateCropRegionElement();
  }

  function initializeCropDrag() {
    let isDragging = false;
    let currentHandle = null;
    let startX, startY;
    let startCrop;

    const startDrag = (e, handle) => {
      isDragging = true;
      currentHandle = handle;
      
      // Get mouse coordinates relative to the container
      const videoPreview = document.getElementById('srcPreview');
      const containerRect = videoPreview.parentElement.getBoundingClientRect();
      const clientX = e.clientX || e.touches[0].clientX;
      const clientY = e.clientY || e.touches[0].clientY;
      
      startX = clientX - containerRect.left;
      startY = clientY - containerRect.top;
      startCrop = { ...cropRegion };
      cropRegionElement.style.transition = 'none';
      
      document.body.classList.add('dragging-active');
      
      // Prevent default behavior and text selection
      e.preventDefault();
      e.stopPropagation();
    };

    const doDrag = (e) => {
      if (!isDragging) return;
      
      e.preventDefault();
      e.stopPropagation();
      
      // Get current mouse coordinates relative to the container
      const videoPreview = document.getElementById('srcPreview');
      const containerRect = videoPreview.parentElement.getBoundingClientRect();
      const clientX = e.touches ? e.touches[0].clientX : e.clientX;
      const clientY = e.touches ? e.touches[0].clientY : e.clientY;
      
      const currentX = clientX - containerRect.left;
      const currentY = clientY - containerRect.top;
      const deltaX = currentX - startX;
      const deltaY = currentY - startY;
      
      // Calculate video content area for dragging calculations (same as updateCropRegionElement)
      const videoWidth = videoPreview.videoWidth;
      const videoHeight = videoPreview.videoHeight;
      
      if (!videoWidth || !videoHeight) return;
      
      const elementWidth = videoPreview.offsetWidth;
      const elementHeight = videoPreview.offsetHeight;
      
      const videoAspectRatio = videoWidth / videoHeight;
      const elementAspectRatio = elementWidth / elementHeight;
      
      let displayWidth, displayHeight;
      
      if (videoAspectRatio > elementAspectRatio) {
        displayWidth = elementWidth;
        displayHeight = elementWidth / videoAspectRatio;
      } else {
        displayHeight = elementHeight;
        displayWidth = elementHeight * videoAspectRatio;
      }
      
      if (currentHandle === 'move') {
        const deltaXPercent = deltaX / displayWidth;
        const deltaYPercent = deltaY / displayHeight;
        
        cropRegion.x = Math.max(0, Math.min(
          1 - cropRegion.width,
          startCrop.x + deltaXPercent
        ));
        cropRegion.y = Math.max(0, Math.min(
          1 - cropRegion.height,
          startCrop.y + deltaYPercent
        ));
      } else {
        const isLeft = currentHandle.includes('w');
        const isTop = currentHandle.includes('n');
        
        const deltaXPercent = deltaX / displayWidth;
        const deltaYPercent = deltaY / displayHeight;
        
        const minSize = 0.05; // 5% minimum size
        
        if (isLeft) {
          const newX = Math.max(0, startCrop.x + deltaXPercent);
          const newWidth = startCrop.width - deltaXPercent;
          if (newWidth >= minSize && newX >= 0) {
            cropRegion.x = newX;
            cropRegion.width = Math.min(1 - newX, newWidth);
          }
        } else {
          const newWidth = startCrop.width + deltaXPercent;
          if (newWidth >= minSize) {
            cropRegion.width = Math.min(1 - cropRegion.x, newWidth);
          }
        }
        
        if (isTop) {
          const newY = Math.max(0, startCrop.y + deltaYPercent);
          const newHeight = startCrop.height - deltaYPercent;
          if (newHeight >= minSize && newY >= 0) {
            cropRegion.y = newY;
            cropRegion.height = Math.min(1 - newY, newHeight);
          }
        } else {
          const newHeight = startCrop.height + deltaYPercent;
          if (newHeight >= minSize) {
            cropRegion.height = Math.min(1 - cropRegion.y, newHeight);
          }
        }
      }
    
      // Round values to 6 decimal places for more precision
      cropRegion.x = Math.round(cropRegion.x * 1000000) / 1000000;
      cropRegion.y = Math.round(cropRegion.y * 1000000) / 1000000;
      cropRegion.width = Math.round(cropRegion.width * 1000000) / 1000000;
      cropRegion.height = Math.round(cropRegion.height * 1000000) / 1000000;

      // Ensure the region doesn't exceed boundaries
      if (cropRegion.x + cropRegion.width > 1) {
        cropRegion.width = 1 - cropRegion.x;
      }
      if (cropRegion.y + cropRegion.height > 1) {
        cropRegion.height = 1 - cropRegion.y;
      }

      updateCropRegionElement();
      updateCropDimensions();
    };

    const endDrag = () => {
      if (!isDragging) return;
      
      isDragging = false;
      currentHandle = null;
      cropRegionElement.style.transition = '';
      
      // Remove dragging class from body
      document.body.classList.remove('dragging-active');
    };

    cropRegionElement.addEventListener('mousedown', (e) => {
      if (e.target === cropRegionElement) {
        startDrag(e, 'move');
      }
    });

    cropRegionElement.querySelectorAll('.crop-handle').forEach(handle => {
      handle.addEventListener('mousedown', (e) => {
        startDrag(e, handle.className.split(' ')[1]);
        e.stopPropagation();
      });
    });

    document.addEventListener('mousemove', doDrag);
    document.addEventListener('mouseup', endDrag);

    cropRegionElement.addEventListener('touchstart', (e) => {
      if (e.target === cropRegionElement) {
        startDrag(e, 'move');
      }
    }, { passive: false });

    cropRegionElement.querySelectorAll('.crop-handle').forEach(handle => {
      handle.addEventListener('touchstart', (e) => {
        startDrag(e, handle.className.split(' ')[1]);
        e.stopPropagation();
      }, { passive: false });
    });

    document.addEventListener('touchmove', doDrag, { passive: false });
    document.addEventListener('touchend', endDrag);
  }

  // Initialize timeline when DOM is ready
  let timeline = null;
  document.addEventListener('DOMContentLoaded', () => {
    const srcPreview = document.getElementById('srcPreview');
    if (srcPreview) {
      timeline = new TimelineController(srcPreview);
      
      // Update crop region when video metadata loads
      srcPreview.addEventListener('loadedmetadata', () => {
        if (cropEnabled) {
          updateCropRegionElement();
        }
      });
    }
    
    // Initialize crop functionality
    initializeCropping();
  });
  </script>
  <script>
    // Theme toggle (light/dark) similar to mosaic tool
    (function(){
      const themeBtn = document.getElementById('themeToggle');
      if (!themeBtn) return;
      const root = document.documentElement;
      const saved = localStorage.getItem('theme');
      const prefersLight = window.matchMedia && window.matchMedia('(prefers-color-scheme: light)').matches;
      const initial = saved || (prefersLight ? 'light' : 'dark');
      if (initial === 'light') { root.setAttribute('data-theme','light'); themeBtn.textContent = 'Dark mode'; themeBtn.setAttribute('aria-pressed','true'); }
      else { root.removeAttribute('data-theme'); themeBtn.textContent = 'Light mode'; themeBtn.setAttribute('aria-pressed','false'); }
      themeBtn.addEventListener('click', () => {
        const isLight = root.getAttribute('data-theme') === 'light';
        if (isLight) { root.removeAttribute('data-theme'); localStorage.setItem('theme','dark'); themeBtn.textContent = 'Light mode'; themeBtn.setAttribute('aria-pressed','false'); }
        else { root.setAttribute('data-theme','light'); localStorage.setItem('theme','light'); themeBtn.textContent = 'Dark mode'; themeBtn.setAttribute('aria-pressed','true'); }
      });
      // Click-to-open for drop zone
      const drop = document.getElementById('drop'); const fileInput = document.getElementById('fileInput');
      if (drop && fileInput) drop.addEventListener('click', () => fileInput.click());
    })();
  </script>
</body>
</html>